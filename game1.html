<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>貪食蛇遊戲</title>
<style>
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background-color: #111;
    color: #fff;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    padding: 20px;
}

.container {
    display: flex;
    flex-direction: column;
    align-items: center;
    max-width: 800px;
    width: 100%;
}

header {
    text-align: center;
    margin-bottom: 20px;
    width: 100%;
}

h1 {
    color: #4CAF50;
    font-size: 2.8rem;
    margin-bottom: 10px;
    text-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
}

.game-info {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 15px;
    width: 100%;
    margin-bottom: 20px;
    background-color: #222;
    padding: 15px;
    border-radius: 10px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
}

.info-container {
    text-align: center;
}

.info-label {
    font-size: 1rem;
    color: #aaa;
    margin-bottom: 5px;
}

.info-value {
    font-size: 1.8rem;
    font-weight: bold;
    color: #4CAF50;
}

.timer-value {
    color: #2196F3;
}

.high-time-value {
    color: #FF9800;
}

.fruit-counter-value {
    color: #9C27B0;
}

.game-container {
    position: relative;
    margin-bottom: 25px;
}

#gameCanvas {
    background-color: #000;
    border: 3px solid #333;
    border-radius: 8px;
    box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
}

.game-status {
    font-size: 1.3rem;
    margin-top: 15px;
    height: 30px;
    color: #ff9800;
    font-weight: bold;
    text-align: center;
    width: 100%;
}

/* 控制按鈕區域 */
.control-buttons {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 100%;
    margin-bottom: 20px;
}

.buttons {
    display: flex;
    gap: 15px;
    margin-bottom: 15px;
}

button {
    padding: 12px 25px;
    background-color: #4CAF50;
    color: white;
    border: none;
    border-radius: 8px;
    font-size: 1.1rem;
    cursor: pointer;
    transition: all 0.3s ease;
    font-weight: bold;
}

button:hover {
    background-color: #45a049;
    transform: translateY(-3px);
    box-shadow: 0 5px 10px rgba(0, 0, 0, 0.2);
}

button:active {
    transform: translateY(0);
}

#pauseBtn {
    background-color: #ff9800;
}

#pauseBtn:hover {
    background-color: #e68900;
}

#restartBtn {
    background-color: #f44336;
}

#restartBtn:hover {
    background-color: #d32f2f;
}

/* 鍵盤控制指示 */
.key-controls {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 15px;
    margin-bottom: 10px;
}

.key {
    background-color: #333;
    padding: 10px 20px;
    border-radius: 8px;
    font-weight: bold;
    min-width: 60px;
    text-align: center;
    box-shadow: 0 3px 5px rgba(0, 0, 0, 0.2);
}

.key.up-down {
    order: 1;
    width: 100%;
    display: flex;
    justify-content: center;
    gap: 15px;
}

.key.left-right {
    order: 2;
    display: flex;
    gap: 15px;
}

/* 遊戲說明 */
.instructions {
    background-color: #222;
    padding: 20px;
    border-radius: 10px;
    margin-top: 10px;
    width: 100%;
    line-height: 1.6;
}

.instructions h2 {
    color: #4CAF50;
    margin-bottom: 10px;
    font-size: 1.5rem;
}

.instructions ul {
    margin-left: 20px;
}

.instructions li {
    margin-bottom: 8px;
}

.instructions .highlight {
    color: #4CAF50;
    font-weight: bold;
}

footer {
    margin-top: 30px;
    text-align: center;
    color: #666;
    font-size: 0.9rem;
    width: 100%;
}

.mobile-controls {
    display: none;
    margin-top: 20px;
    width: 100%;
}

.mobile-controls-grid {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    grid-template-rows: 1fr 1fr;
    gap: 10px;
    max-width: 300px;
    margin: 0 auto;
}

.mobile-btn {
    background-color: #333;
    color: white;
    border: none;
    border-radius: 10px;
    font-size: 1.8rem;
    height: 70px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    user-select: none;
}

.mobile-btn.up {
    grid-column: 2;
    grid-row: 1;
}

.mobile-btn.left {
    grid-column: 1;
    grid-row: 2;
}

.mobile-btn.right {
    grid-column: 3;
    grid-row: 2;
}

.mobile-btn.down {
    grid-column: 2;
    grid-row: 2;
}

@media (max-width: 768px) {
    .game-info {
        grid-template-columns: repeat(2, 1fr);
        gap: 15px;
    }
    
    .key-controls {
        display: none;
    }
    
    .mobile-controls {
        display: block;
    }
    
    h1 {
        font-size: 2.2rem;
    }
    
    #gameCanvas {
        width: 100%;
        height: auto;
    }
    
    .buttons {
        flex-direction: column;
        width: 100%;
    }
    
    button {
        width: 100%;
    }
}

@media (max-width: 480px) {
    h1 {
        font-size: 1.8rem;
    }
    
    .instructions {
        padding: 15px;
    }
    
    .info-label {
        font-size: 0.9rem;
    }
    
    .info-value {
        font-size: 1.5rem;
    }
}
</style>
</head>
<body>
<div class="container">
    <header>
        <h1>貪食蛇遊戲</h1>
        <p>吃掉水果讓蛇變長，避開牆壁和自己的身體！</p>
    </header>
    
    <div class="game-info">
        <div class="info-container">
            <div class="info-label">當前分數</div>
            <div id="score" class="info-value">0</div>
        </div>
        <div class="info-container">
            <div class="info-label">最高分數</div>
            <div id="highScore" class="info-value">0</div>
        </div>
        <div class="info-container">
            <div class="info-label">遊戲時間</div>
            <div id="timer" class="info-value timer-value">00:00</div>
        </div>
        <div class="info-container">
            <div class="info-label">最佳時間</div>
            <div id="highTime" class="info-value high-time-value">00:00</div>
        </div>
        <div class="info-container">
            <div class="info-label">水果計數</div>
            <div id="fruitCounter" class="info-value fruit-counter-value">0/5</div>
        </div>
        <div class="info-container">
            <div class="info-label">水果數量</div>
            <div id="foodCount" class="info-value">3</div>
        </div>
        <div class="info-container">
            <div class="info-label">蛇身長度</div>
            <div id="snakeLength" class="info-value">3</div>
        </div>
        <div class="info-container">
            <div class="info-label">遊戲速度</div>
            <div id="gameSpeed" class="info-value">慢</div>
        </div>
    </div>
    
    <div class="game-container">
        <canvas id="gameCanvas" width="600" height="400"></canvas>
    </div>
    
    <div id="gameStatus" class="game-status">點擊「開始遊戲」按鈕開始</div>
    
    <!-- 控制按鈕區域（在遊戲畫布下方，說明上方） -->
    <div class="control-buttons">
        <div class="buttons">
            <button id="startBtn">開始遊戲</button>
            <button id="pauseBtn">暫停遊戲</button>
            <button id="restartBtn">重新開始</button>
        </div>
        
        <div class="key-controls">
            <div class="key up-down">
                <div class="key">W / ↑</div>
            </div>
            <div class="key left-right">
                <div class="key">A / ←</div>
                <div class="key">S / ↓</div>
                <div class="key">D / →</div>
            </div>
        </div>
        
        <div class="mobile-controls">
            <div class="mobile-controls-grid">
                <button class="mobile-btn up" id="upBtn">↑</button>
                <button class="mobile-btn left" id="leftBtn">←</button>
                <button class="mobile-btn right" id="rightBtn">→</button>
                <button class="mobile-btn down" id="downBtn">↓</button>
            </div>
        </div>
    </div>
    
    <!-- 遊戲說明（在控制按鈕下方） -->
    <div class="instructions">
        <h2>遊戲說明</h2>
        <ul>
            <li>使用鍵盤<span class="highlight">方向鍵</span>或<span class="highlight">WASD</span>控制蛇的移動方向</li>
            <li><span class="highlight">觸控設備</span>：在遊戲畫面上<span class="highlight">滑動手指</span>來控制方向</li>
            <li>蛇需要吃掉<span class="highlight">水果</span>才能變長並增加分數</li>
            <li>每吃掉一個水果得<span class="highlight">10分</span></li>
            <li><span class="highlight">每吃掉5個水果：</span>
                <ul style="margin-left: 20px; margin-top: 5px;">
                    <li>蛇身會<span class="highlight">變色</span></li>
                    <li>水果會<span class="highlight">變換</span>種類</li>
                    <li>立即加<span class="highlight">100分</span>獎勵</li>
                </ul>
            </li>
            <li><span class="highlight">多個水果</span>同時出現在遊戲中，增加挑戰性</li>
            <li><span class="highlight">計時器</span>記錄你的遊戲時間，挑戰最佳記錄！</li>
            <li>遊戲開始速度為<span class="highlight">慢速</span>，隨著<span class="highlight">分數增加</span>速度會<span class="highlight">逐漸加快</span>（每100分加速一次）</li>
            <li>蛇撞到<span class="highlight">牆壁</span>或<span class="highlight">自己的身體</span>遊戲結束</li>
            <li>點擊<span class="highlight">暫停/繼續</span>按鈕可以暫停遊戲，或按<span class="highlight">P鍵/空格鍵</span></li>
            <li><span class="highlight">觸控反饋</span>：滑動時會顯示方向箭頭提示</li>
        </ul>
    </div>
    
    <footer>
        <p>HTML5 貪食蛇遊戲 | 使用方向鍵控制，吃掉水果變長</p>
    </footer>
</div>

<script>
// 遊戲變數
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreElement = document.getElementById('score');
const highScoreElement = document.getElementById('highScore');
const timerElement = document.getElementById('timer');
const highTimeElement = document.getElementById('highTime');
const gameStatusElement = document.getElementById('gameStatus');
const fruitCounterElement = document.getElementById('fruitCounter');
const foodCountElement = document.getElementById('foodCount');
const snakeLengthElement = document.getElementById('snakeLength');
const gameSpeedElement = document.getElementById('gameSpeed');
const startBtn = document.getElementById('startBtn');
const pauseBtn = document.getElementById('pauseBtn');
const restartBtn = document.getElementById('restartBtn');

// 移動按鈕 (移動設備)
const upBtn = document.getElementById('upBtn');
const downBtn = document.getElementById('downBtn');
const leftBtn = document.getElementById('leftBtn');
const rightBtn = document.getElementById('rightBtn');

// 遊戲設定
const gridSize = 20;
const gridWidth = canvas.width / gridSize;
const gridHeight = canvas.height / gridSize;

let snake = [];
let foods = []; // 改為食物陣列
let direction = 'right';
let nextDirection = 'right';
let gameSpeedValue = 180; // 改為慢速開始（原來是120）
let gameInterval;
let score = 0;
let highScore = localStorage.getItem('snakeHighScore') || 0;
let gameRunning = false;
let gamePaused = false;

// 新增加的功能變數
let fruitCount = 0; // 吃水果計數器
let snakeColorIndex = 0; // 蛇身顏色索引
let fruitTypeIndex = 0; // 水果類型索引
let lastSpeedUpdateScore = 0; // 記錄上次更新速度時的分數

// 計時器變數
let startTime = 0;
let elapsedTime = 0;
let timerInterval;
let highTime = localStorage.getItem('snakeHighTime') || 0;

// 食物設定
const MAX_FOODS = 5; // 同時最多食物數量
const MIN_FOODS = 3; // 最少食物數量
let currentFoodCount = MIN_FOODS;

// 蛇身顏色陣列
const snakeColors = [
    '#4CAF50', // 綠色 (預設)
    '#2196F3', // 藍色
    '#FF9800', // 橙色
    '#9C27B0', // 紫色
    '#FF5722', // 深橙色
    '#00BCD4', // 青色
    '#E91E63', // 粉色
    '#8BC34A'  // 淺綠色
];

// 水果類型陣列
const fruitTypes = [
    { name: '蘋果', color: '#FF5252', stemColor: '#8D6E63', leafColor: '#7CB342' },
    { name: '橘子', color: '#FF9800', stemColor: '#8D6E63', leafColor: '#7CB342' },
    { name: '藍莓', color: '#2196F3', stemColor: '#5D4037', leafColor: '#7CB342' },
    { name: '葡萄', color: '#9C27B0', stemColor: '#5D4037', leafColor: '#7CB342' },
    { name: '香蕉', color: '#FFEB3B', stemColor: '#8D6E63', leafColor: '#7CB342' },
    { name: '草莓', color: '#F44336', stemColor: '#8D6E63', leafColor: '#7CB342' },
    { name: '西瓜', color: '#4CAF50', stemColor: '#8D6E63', leafColor: '#7CB342' },
    { name: '鳳梨', color: '#FFC107', stemColor: '#8D6E63', leafColor: '#7CB342' }
];

// 格式化時間
function formatTime(seconds) {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
}

// 更新計時器
function updateTimer() {
    if (gameRunning && !gamePaused) {
        elapsedTime = Math.floor((Date.now() - startTime) / 1000);
        timerElement.textContent = formatTime(elapsedTime);
        
        // 隨著時間增加食物數量（每30秒增加一個）
        if (elapsedTime % 30 === 0 && foods.length < MAX_FOODS && elapsedTime > 0) {
            generateFood();
            gameStatusElement.textContent = `遊戲進行${elapsedTime}秒，新增一個水果！`;
            setTimeout(() => {
                if (gameRunning && !gamePaused) {
                    gameStatusElement.textContent = '遊戲進行中';
                }
            }, 1500);
        }
    }
}

// 開始計時器
function startTimer() {
    startTime = Date.now() - (elapsedTime * 1000);
    timerInterval = setInterval(updateTimer, 1000);
}

// 停止計時器
function stopTimer() {
    clearInterval(timerInterval);
}

// 更新最佳時間
function updateHighTime() {
    if (elapsedTime > highTime) {
        highTime = elapsedTime;
        highTimeElement.textContent = formatTime(highTime);
        localStorage.setItem('snakeHighTime', highTime);
    }
}

// 初始化遊戲
function initGame() {
    // 初始化蛇 - 從中間開始，長度為3
    snake = [
        {x: Math.floor(gridWidth / 2), y: Math.floor(gridHeight / 2)},
        {x: Math.floor(gridWidth / 2) - 1, y: Math.floor(gridHeight / 2)},
        {x: Math.floor(gridWidth / 2) - 2, y: Math.floor(gridHeight / 2)}
    ];
    
    // 初始化食物陣列
    foods = [];
    currentFoodCount = MIN_FOODS;
    for (let i = 0; i < currentFoodCount; i++) {
        generateFood();
    }
    
    // 重置方向
    direction = 'right';
    nextDirection = 'right';
    
    // 重置遊戲速度為慢速
    gameSpeedValue = 180;
    lastSpeedUpdateScore = 0;
    
    // 重置分數
    score = 0;
    scoreElement.textContent = score;
    highScoreElement.textContent = highScore;
    
    // 重置水果計數器和顏色索引
    fruitCount = 0;
    snakeColorIndex = 0;
    fruitTypeIndex = 0;
    fruitCounterElement.textContent = `${fruitCount}/5`;
    
    // 重置計時器
    elapsedTime = 0;
    timerElement.textContent = '00:00';
    highTimeElement.textContent = formatTime(highTime);
    
    // 更新顯示資訊
    updateDisplayInfo();
    
    // 重置遊戲狀態
    gameStatusElement.textContent = '點擊「開始遊戲」按鈕開始';
    gameRunning = false;
    gamePaused = false;
    
    // 停止計時器
    stopTimer();
    
    // 繪製初始狀態
    draw();
}

// 更新顯示資訊
function updateDisplayInfo() {
    foodCountElement.textContent = foods.length;
    snakeLengthElement.textContent = snake.length;
    
    // 更新遊戲速度顯示
    if (gameSpeedValue <= 100) {
        gameSpeedElement.textContent = '快';
    } else if (gameSpeedValue <= 150) {
        gameSpeedElement.textContent = '中';
    } else {
        gameSpeedElement.textContent = '慢';
    }
}

// 檢查並更新遊戲速度（根據分數） - 修正為每100分加速一次
function updateGameSpeed() {
    // 每增加100分，遊戲速度加快一次（從50分改為100分）
    const speedIncreaseThreshold = 100;
    
    // 計算應該增加幾次速度
    const speedIncreases = Math.floor((score - lastSpeedUpdateScore) / speedIncreaseThreshold);
    
    if (speedIncreases > 0) {
        // 每次加速減少15毫秒，但最低不低於60毫秒
        const newSpeed = Math.max(60, gameSpeedValue - (speedIncreases * 15));
        
        if (newSpeed < gameSpeedValue) {
            gameSpeedValue = newSpeed;
            
            // 更新遊戲間隔
            clearInterval(gameInterval);
            gameInterval = setInterval(update, gameSpeedValue);
            
            // 更新顯示
            updateDisplayInfo();
            
            // 顯示速度變化提示
            let speedLevel = '慢';
            if (gameSpeedValue <= 100) speedLevel = '快';
            else if (gameSpeedValue <= 150) speedLevel = '中';
            
            gameStatusElement.textContent = `分數達到${score}，遊戲速度已加快為${speedLevel}速！`;
            setTimeout(() => {
                if (gameRunning && !gamePaused) {
                    gameStatusElement.textContent = '遊戲進行中';
                }
            }, 1500);
            
            // 更新記錄（確保下次在正確的分數閾值檢查）
            lastSpeedUpdateScore = score - (score % speedIncreaseThreshold);
        }
    }
}

// 生成食物
function generateFood() {
    // 隨機位置
    const food = {
        x: Math.floor(Math.random() * gridWidth),
        y: Math.floor(Math.random() * gridHeight),
        type: fruitTypes[fruitTypeIndex] // 使用當前水果類型
    };
    
    // 確保食物不會生成在蛇身上
    for (let segment of snake) {
        if (segment.x === food.x && segment.y === food.y) {
            return generateFood(); // 遞迴直到找到空位置
        }
    }
    
    // 確保食物不會生成在其他食物上
    for (let existingFood of foods) {
        if (existingFood.x === food.x && existingFood.y === food.y) {
            return generateFood(); // 遞迴直到找到空位置
        }
    }
    
    // 將食物加入陣列
    foods.push(food);
    updateDisplayInfo();
}

// 繪製遊戲
function draw() {
    // 清除畫布
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // 繪製蛇
    for (let i = 0; i < snake.length; i++) {
        // 蛇頭用不同顏色
        if (i === 0) {
            ctx.fillStyle = '#4CAF50'; // 蛇頭 - 綠色
        } else {
            // 蛇身使用當前顏色索引的顏色
            ctx.fillStyle = snakeColors[snakeColorIndex];
            
            // 添加漸變效果
            const intensity = 150 + Math.floor(105 * (i / snake.length));
            if (snakeColorIndex === 0) {
                // 預設綠色保持原漸變
                ctx.fillStyle = `rgb(76, ${intensity}, 80)`;
            }
        }
        
        ctx.fillRect(
            snake[i].x * gridSize,
            snake[i].y * gridSize,
            gridSize - 1,
            gridSize - 1
        );
        
        // 蛇頭眼睛
        if (i === 0) {
            ctx.fillStyle = '#000';
            const eyeSize = gridSize / 5;
            
            // 根據方向繪製眼睛位置
            if (direction === 'right') {
                ctx.fillRect(
                    snake[i].x * gridSize + gridSize - eyeSize * 2,
                    snake[i].y * gridSize + eyeSize,
                    eyeSize, eyeSize
                );
                ctx.fillRect(
                    snake[i].x * gridSize + gridSize - eyeSize * 2,
                    snake[i].y * gridSize + gridSize - eyeSize * 2,
                    eyeSize, eyeSize
                );
            } else if (direction === 'left') {
                ctx.fillRect(
                    snake[i].x * gridSize + eyeSize,
                    snake[i].y * gridSize + eyeSize,
                    eyeSize, eyeSize
                );
                ctx.fillRect(
                    snake[i].x * gridSize + eyeSize,
                    snake[i].y * gridSize + gridSize - eyeSize * 2,
                    eyeSize, eyeSize
                );
            } else if (direction === 'up') {
                ctx.fillRect(
                    snake[i].x * gridSize + eyeSize,
                    snake[i].y * gridSize + eyeSize,
                    eyeSize, eyeSize
                );
                ctx.fillRect(
                    snake[i].x * gridSize + gridSize - eyeSize * 2,
                    snake[i].y * gridSize + eyeSize,
                    eyeSize, eyeSize
                );
            } else if (direction === 'down') {
                ctx.fillRect(
                    snake[i].x * gridSize + eyeSize,
                    snake[i].y * gridSize + gridSize - eyeSize * 2,
                    eyeSize, eyeSize
                );
                ctx.fillRect(
                    snake[i].x * gridSize + gridSize - eyeSize * 2,
                    snake[i].y * gridSize + gridSize - eyeSize * 2,
                    eyeSize, eyeSize
                );
            }
        }
    }
    
    // 繪製所有食物
    for (let food of foods) {
        const currentFruit = food.type;
        ctx.fillStyle = currentFruit.color;
        
        // 根據水果類型繪製不同形狀
        if (currentFruit.name === '香蕉') {
            // 香蕉形狀
            ctx.beginPath();
            const foodX = food.x * gridSize + gridSize / 2;
            const foodY = food.y * gridSize + gridSize / 2;
            ctx.moveTo(foodX - gridSize/3, foodY);
            ctx.bezierCurveTo(
                foodX - gridSize/4, foodY - gridSize/3,
                foodX + gridSize/4, foodY - gridSize/3,
                foodX + gridSize/3, foodY
            );
            ctx.bezierCurveTo(
                foodX + gridSize/4, foodY + gridSize/3,
                foodX - gridSize/4, foodY + gridSize/3,
                foodX - gridSize/3, foodY
            );
            ctx.closePath();
            ctx.fill();
        } else {
            // 圓形水果 (蘋果、橘子等)
            ctx.beginPath();
            const foodX = food.x * gridSize + gridSize / 2;
            const foodY = food.y * gridSize + gridSize / 2;
            const radius = gridSize / 2 - 2;
            ctx.arc(foodX, foodY, radius, 0, Math.PI * 2);
            ctx.fill();
            
            // 水果梗
            ctx.fillStyle = currentFruit.stemColor;
            ctx.fillRect(foodX - 1, foodY - radius - 3, 2, 5);
            
            // 水果葉子
            ctx.fillStyle = currentFruit.leafColor;
            ctx.beginPath();
            ctx.ellipse(foodX + 5, foodY - radius - 2, 4, 2, 0, 0, Math.PI * 2);
            ctx.fill();
        }
    }
}

// 更新遊戲狀態
function update() {
    // 更新方向
    direction = nextDirection;
    
    // 根據方向計算新蛇頭位置
    let head = {x: snake[0].x, y: snake[0].y};
    switch(direction) {
        case 'up':
            head.y--;
            break;
        case 'down':
            head.y++;
            break;
        case 'left':
            head.x--;
            break;
        case 'right':
            head.x++;
            break;
    }
    
    // 檢查是否撞牆
    if (head.x < 0 || head.x >= gridWidth || head.y < 0 || head.y >= gridHeight) {
        gameOver();
        return;
    }
    
    // 檢查是否撞到自己
    for (let segment of snake) {
        if (head.x === segment.x && head.y === segment.y) {
            gameOver();
            return;
        }
    }
    
    // 將新蛇頭加入陣列開頭
    snake.unshift(head);
    
    // 檢查是否吃到食物
    let ateFood = false;
    for (let i = foods.length - 1; i >= 0; i--) {
        if (head.x === foods[i].x && head.y === foods[i].y) {
            // 移除被吃掉的食物
            foods.splice(i, 1);
            
            // 增加水果計數
            fruitCount++;
            fruitCounterElement.textContent = `${fruitCount}/5`;
            
            // 增加分數
            score += 10;
            scoreElement.textContent = score;
            
            // 檢查是否達到5個水果
            if (fruitCount >= 5) {
                // 立即加100分
                score += 100;
                scoreElement.textContent = score;
                
                // 蛇身變色
                snakeColorIndex = (snakeColorIndex + 1) % snakeColors.length;
                
                // 水果變換為另一種水果
                fruitTypeIndex = (fruitTypeIndex + 1) % fruitTypes.length;
                
                // 重置水果計數器
                fruitCount = 0;
                fruitCounterElement.textContent = `${fruitCount}/5`;
                
                // 顯示特效訊息
                gameStatusElement.textContent = `恭喜！吃到5個水果，蛇身變色，獲得100分！`;
                setTimeout(() => {
                    if (gameRunning && !gamePaused) {
                        gameStatusElement.textContent = '遊戲進行中';
                    }
                }, 2000);
            }
            
            // 檢查並更新遊戲速度（根據分數）
            updateGameSpeed();
            
            // 生成新食物 (確保有足夠的食物)
            if (foods.length < MAX_FOODS) {
                generateFood();
            }
            
            ateFood = true;
            break;
        }
    }
    
    // 如果沒吃到食物，移除蛇尾
    if (!ateFood) {
        snake.pop();
    }
    
    // 確保有足夠的食物
    while (foods.length < MIN_FOODS) {
        generateFood();
    }
    
    // 更新最高分
    if (score > highScore) {
        highScore = score;
        highScoreElement.textContent = highScore;
        localStorage.setItem('snakeHighScore', highScore);
    }
    
    // 更新顯示資訊
    updateDisplayInfo();
    
    // 繪製更新後的遊戲狀態
    draw();
}

// 遊戲開始
function startGame() {
    if (!gameRunning) {
        gameRunning = true;
        gamePaused = false;
        gameStatusElement.textContent = '遊戲進行中';
        gameInterval = setInterval(update, gameSpeedValue);
        startBtn.textContent = '遊戲進行中';
        startBtn.disabled = true;
        
        // 開始計時器
        startTimer();
    }
}

// 暫停/繼續遊戲
function togglePause() {
    if (!gameRunning) return;
    
    if (gamePaused) {
        // 繼續遊戲
        gamePaused = false;
        gameStatusElement.textContent = '遊戲進行中';
        gameInterval = setInterval(update, gameSpeedValue);
        pauseBtn.textContent = '暫停遊戲';
        
        // 繼續計時器
        startTimer();
    } else {
        // 暫停遊戲
        gamePaused = true;
        clearInterval(gameInterval);
        gameStatusElement.textContent = '遊戲已暫停';
        pauseBtn.textContent = '繼續遊戲';
        
        // 停止計時器
        stopTimer();
    }
}

// 遊戲結束
function gameOver() {
    gameRunning = false;
    clearInterval(gameInterval);
    
    // 停止計時器
    stopTimer();
    
    // 更新最佳時間
    updateHighTime();
    
    gameStatusElement.textContent = `遊戲結束！最終分數: ${score}，遊戲時間: ${formatTime(elapsedTime)}`;
    startBtn.textContent = '重新開始';
    startBtn.disabled = false;
    
    // 繪製遊戲結束畫面
    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    ctx.fillStyle = '#fff';
    ctx.font = '36px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('遊戲結束', canvas.width / 2, canvas.height / 2 - 50);
    
    ctx.font = '24px Arial';
    ctx.fillText(`分數: ${score}`, canvas.width / 2, canvas.height / 2 - 10);
    ctx.fillText(`最高分數: ${highScore}`, canvas.width / 2, canvas.height / 2 + 20);
    ctx.fillText(`遊戲時間: ${formatTime(elapsedTime)}`, canvas.width / 2, canvas.height / 2 + 50);
    ctx.fillText(`最佳時間: ${formatTime(highTime)}`, canvas.width / 2, canvas.height / 2 + 80);
}

// 鍵盤控制
function handleKeyDown(e) {
    // 防止方向鍵滾動頁面
    if ([37, 38, 39, 40].includes(e.keyCode)) {
        e.preventDefault();
    }
    
    // 只有在遊戲運行中且未暫停時才接受方向鍵輸入
    if (!gameRunning || gamePaused) return;
    
    switch(e.keyCode) {
        case 38: // 上箭頭
        case 87: // W
            if (direction !== 'down') nextDirection = 'up';
            break;
        case 40: // 下箭頭
        case 83: // S
            if (direction !== 'up') nextDirection = 'down';
            break;
        case 37: // 左箭頭
        case 65: // A
            if (direction !== 'right') nextDirection = 'left';
            break;
        case 39: // 右箭頭
        case 68: // D
            if (direction !== 'left') nextDirection = 'right';
            break;
    }
}

// 事件監聽
document.addEventListener('keydown', handleKeyDown);

startBtn.addEventListener('click', function() {
    if (!gameRunning) {
        initGame();
        startGame();
    }
});

pauseBtn.addEventListener('click', togglePause);

restartBtn.addEventListener('click', function() {
    clearInterval(gameInterval);
    stopTimer();
    initGame();
    if (!gamePaused) {
        startGame();
    }
});

// 移動設備控制
upBtn.addEventListener('click', () => {
    if (gameRunning && !gamePaused && direction !== 'down') nextDirection = 'up';
});

downBtn.addEventListener('click', () => {
    if (gameRunning && !gamePaused && direction !== 'up') nextDirection = 'down';
});

leftBtn.addEventListener('click', () => {
    if (gameRunning && !gamePaused && direction !== 'right') nextDirection = 'left';
});

rightBtn.addEventListener('click', () => {
    if (gameRunning && !gamePaused && direction !== 'left') nextDirection = 'right';
});

// 觸控事件防止滾動
[upBtn, downBtn, leftBtn, rightBtn].forEach(btn => {
    btn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        btn.click();
    });
});

// ==================== 觸控滑動手勢控制 ====================
let touchStartX = 0;
let touchStartY = 0;
let touchEndX = 0;
let touchEndY = 0;
let minSwipeDistance = 30; // 最小滑動距離（像素）

// 添加觸控事件監聽器到Canvas
canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
canvas.addEventListener('touchend', handleTouchEnd, { passive: false });

function handleTouchStart(e) {
    e.preventDefault();
    const touch = e.touches[0];
    touchStartX = touch.clientX;
    touchStartY = touch.clientY;
    touchEndX = touchStartX;
    touchEndY = touchStartY;
}

function handleTouchMove(e) {
    e.preventDefault();
    const touch = e.touches[0];
    touchEndX = touch.clientX;
    touchEndY = touch.clientY;
}

function handleTouchEnd(e) {
    e.preventDefault();
    
    // 計算滑動距離
    const dx = touchEndX - touchStartX;
    const dy = touchEndY - touchStartY;
    
    // 計算絕對距離
    const absDx = Math.abs(dx);
    const absDy = Math.abs(dy);
    
    // 檢查是否達到最小滑動距離
    if (Math.max(absDx, absDy) < minSwipeDistance) {
        return; // 滑動距離太小，忽略
    }
    
    // 只有在遊戲運行中且未暫停時才處理方向改變
    if (!gameRunning || gamePaused) return;
    
    // 判斷主要滑動方向
    if (absDx > absDy) {
        // 水平滑動
        if (dx > 0 && direction !== 'left') {
            nextDirection = 'right';
            showSwipeFeedback('→', touchEndX, touchEndY);
        } else if (dx < 0 && direction !== 'right') {
            nextDirection = 'left';
            showSwipeFeedback('←', touchEndX, touchEndY);
        }
    } else {
        // 垂直滑動
        if (dy > 0 && direction !== 'up') {
            nextDirection = 'down';
            showSwipeFeedback('↓', touchEndX, touchEndY);
        } else if (dy < 0 && direction !== 'down') {
            nextDirection = 'up';
            showSwipeFeedback('↑', touchEndX, touchEndY);
        }
    }
    
    // 重置觸控點
    touchStartX = 0;
    touchStartY = 0;
    touchEndX = 0;
    touchEndY = 0;
}

// 顯示滑動反饋
function showSwipeFeedback(directionSymbol, x, y) {
    // 創建反饋元素
    const feedback = document.createElement('div');
    feedback.textContent = directionSymbol;
    feedback.style.position = 'fixed';
    feedback.style.left = (x - 20) + 'px';
    feedback.style.top = (y - 20) + 'px';
    feedback.style.fontSize = '40px';
    feedback.style.color = '#4CAF50';
    feedback.style.fontWeight = 'bold';
    feedback.style.opacity = '0.8';
    feedback.style.pointerEvents = 'none';
    feedback.style.zIndex = '1000';
    feedback.style.transition = 'all 0.3s ease';
    
    document.body.appendChild(feedback);
    
    // 動畫效果
    setTimeout(() => {
        feedback.style.transform = 'translateY(-20px)';
        feedback.style.opacity = '0';
    }, 10);
    
    // 移除元素
    setTimeout(() => {
        if (feedback.parentNode) {
            feedback.parentNode.removeChild(feedback);
        }
    }, 300);
}

// ==================== 遊戲暫停功能 (P鍵) ====================
document.addEventListener('keydown', (e) => {
    // 檢查是否按下P鍵暫停遊戲
    if (e.key === 'p' || e.key === 'P') {
        e.preventDefault();
        togglePause();
    }
    
    // 檢查是否按下空格鍵開始/暫停遊戲
    if (e.key === ' ' && gameRunning) {
        e.preventDefault();
        togglePause();
    }
});

// ==================== 觸控設備檢測和優化 ====================
function setupTouchOptimizations() {
    // 檢測是否為觸控設備
    if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
        // 添加觸控設備提示
        const touchHint = document.createElement('div');
        touchHint.className = 'touch-hint';
        touchHint.innerHTML = `
            <div style="
                background: rgba(0, 0, 0, 0.8);
                color: white;
                padding: 10px 15px;
                border-radius: 10px;
                margin-top: 10px;
                text-align: center;
                font-size: 14px;
                border: 1px solid #4CAF50;
            ">
                <strong>觸控控制提示：</strong>
                在遊戲畫面上滑動手指來控制蛇的移動方向
            </div>
        `;
        
        const gameContainer = document.querySelector('.game-container');
        if (gameContainer) {
            gameContainer.appendChild(touchHint);
            
            // 5秒後自動隱藏提示
            setTimeout(() => {
                touchHint.style.opacity = '0';
                touchHint.style.transition = 'opacity 0.5s ease';
                setTimeout(() => {
                    if (touchHint.parentNode) {
                        touchHint.parentNode.removeChild(touchHint);
                    }
                }, 500);
            }, 5000);
        }
        
        // 優化移動按鈕顯示
        const mobileControls = document.querySelector('.mobile-controls');
        if (mobileControls) {
            mobileControls.style.display = 'block';
        }
    }
}

// ==================== 錯誤處理和性能監控 ====================
function setupErrorHandling() {
    // 捕獲遊戲錯誤
    window.addEventListener('error', function(e) {
        console.error('遊戲錯誤:', e.error);
        gameStatusElement.textContent = '遊戲發生錯誤，請重新開始';
        
        // 嘗試恢復遊戲
        if (gameRunning) {
            gameRunning = false;
            clearInterval(gameInterval);
            stopTimer();
        }
    });
    
    // 捕獲未處理的Promise錯誤
    window.addEventListener('unhandledrejection', function(e) {
        console.error('未處理的Promise錯誤:', e.reason);
    });
}

// 初始化觸控優化和錯誤處理
setupTouchOptimizations();
setupErrorHandling();

// 初始化遊戲
initGame();
</script>
</body>
</html>