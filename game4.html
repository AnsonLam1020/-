<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>極速賽車 - HTML5賽車遊戲</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Microsoft JhengHei', sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
            color: #fff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            overflow-x: hidden;
        }
        
        .header {
            text-align: center;
            margin-bottom: 20px;
            width: 100%;
            max-width: 900px;
        }
        
        h1 {
            font-size: 3.2rem;
            color: #FFD700;
            text-shadow: 0 0 10px #FF4500, 0 0 20px #FF8C00;
            margin-bottom: 8px;
            letter-spacing: 3px;
        }
        
        .subtitle {
            font-size: 1.4rem;
            color: #00FFFF;
            margin-bottom: 20px;
            text-shadow: 0 0 5px #00BFFF;
        }
        
        .game-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            width: 100%;
            max-width: 1200px;
        }
        
        .game-section {
            flex: 1;
            min-width: 300px;
            max-width: 800px;
            position: relative;
        }
        
        .info-section {
            flex: 1;
            min-width: 300px;
            max-width: 350px;
            background: rgba(0, 20, 40, 0.7);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 0 20px rgba(0, 150, 255, 0.3);
            border: 2px solid #0055AA;
        }
        
        #gameCanvas {
            background-color: #111;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(255, 100, 0, 0.5);
            border: 3px solid #FF8C00;
            display: block;
            margin: 0 auto;
        }
        
        .control-panel {
            background: rgba(0, 30, 60, 0.8);
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
            text-align: center;
        }
        
        .panel-title {
            color: #FFD700;
            font-size: 1.5rem;
            margin-bottom: 15px;
            border-bottom: 2px solid #FF8C00;
            padding-bottom: 5px;
        }
        
        .stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .stat-box {
            background: rgba(0, 50, 100, 0.7);
            padding: 12px;
            border-radius: 8px;
            border-left: 4px solid #00BFFF;
        }
        
        .stat-label {
            font-size: 0.9rem;
            color: #87CEEB;
        }
        
        .stat-value {
            font-size: 1.5rem;
            color: #FFFFFF;
            font-weight: bold;
            text-shadow: 0 0 5px #00BFFF;
        }
        
        .controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 20px;
        }
        
        .button {
            padding: 12px 20px;
            font-size: 1.1rem;
            background: linear-gradient(to bottom, #FF8C00, #FF4500);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: bold;
            letter-spacing: 1px;
        }
        
        .button:hover {
            background: linear-gradient(to bottom, #FFA500, #FF6347);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 69, 0, 0.4);
        }
        
        .button:active {
            transform: translateY(1px);
        }
        
        .button.secondary {
            background: linear-gradient(to bottom, #0055AA, #003366);
        }
        
        .button.secondary:hover {
            background: linear-gradient(to bottom, #0066CC, #004488);
        }
        
        .instructions {
            margin-top: 25px;
            padding: 15px;
            background: rgba(0, 40, 80, 0.6);
            border-radius: 10px;
            border-left: 4px solid #00FF00;
        }
        
        .instructions h3 {
            color: #00FF00;
            margin-bottom: 10px;
        }
        
        .instructions ul {
            padding-left: 20px;
        }
        
        .instructions li {
            margin-bottom: 8px;
            line-height: 1.4;
        }
        
        .track-selector {
            display: flex;
            justify-content: space-between;
            margin-top: 15px;
        }
        
        .track-btn {
            padding: 10px;
            background: rgba(0, 60, 120, 0.7);
            border: 2px solid #0055AA;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            flex: 1;
            margin: 0 5px;
            transition: all 0.2s;
        }
        
        .track-btn:hover {
            background: rgba(0, 80, 160, 0.9);
            transform: translateY(-2px);
        }
        
        .track-btn.active {
            background: rgba(255, 140, 0, 0.9);
            border-color: #FFD700;
        }
        
        .lap-times {
            margin-top: 20px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .lap-times table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .lap-times th {
            background-color: rgba(0, 80, 160, 0.8);
            padding: 8px;
            text-align: left;
        }
        
        .lap-times td {
            padding: 8px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .lap-times tr:nth-child(even) {
            background-color: rgba(0, 40, 80, 0.4);
        }
        
        .lap-times tr:hover {
            background-color: rgba(0, 100, 200, 0.4);
        }
        
        .best-lap {
            color: #FFD700;
            font-weight: bold;
        }
        
        .ranking {
            margin-top: 20px;
        }
        
        .ranking-item {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            background: rgba(0, 50, 100, 0.6);
            margin-bottom: 8px;
            border-radius: 5px;
            border-left: 4px solid;
        }
        
        .player {
            border-left-color: #FF8C00;
        }
        
        .opponent {
            border-left-color: #0055AA;
        }
        
        .ranking-position {
            font-weight: bold;
            color: #FFD700;
            min-width: 30px;
        }
        
        .ranking-name {
            flex-grow: 1;
            margin-left: 10px;
        }
        
        .ranking-lap {
            color: #87CEEB;
            margin-right: 10px;
        }
        
        .ranking-time {
            color: #87CEEB;
            min-width: 80px;
            text-align: right;
        }
        
        footer {
            margin-top: 30px;
            text-align: center;
            color: #87CEEB;
            font-size: 0.9rem;
            padding: 15px;
            border-top: 1px solid rgba(0, 150, 255, 0.3);
            width: 100%;
            max-width: 1200px;
        }
        
        @media (max-width: 768px) {
            .game-container {
                flex-direction: column;
            }
            
            h1 {
                font-size: 2.5rem;
            }
            
            #gameCanvas {
                width: 100%;
                height: auto;
            }
        }
        
        /* 防止頁面滾動的樣式 */
        body.no-scroll {
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>極速賽車</h1>
        <div class="subtitle">駕駛賽車在各種賽道上飛馳，超越對手，創造最快圈速！</div>
    </div>
    
    <div class="game-container">
        <div class="game-section">
            <canvas id="gameCanvas" width="800" height="600"></canvas>
            
            <div class="control-panel">
                <div class="track-selector">
                    <div class="track-btn active" data-track="1">城市賽道</div>
                    <div class="track-btn" data-track="2">山區賽道</div>
                    <div class="track-btn" data-track="3">沙漠賽道</div>
                </div>
                
                <div class="controls">
                    <button id="startBtn" class="button">開始比賽</button>
                    <button id="restartBtn" class="button secondary">重新開始</button>
                    <button id="pauseBtn" class="button secondary">暫停/繼續</button>
                </div>
            </div>
        </div>
        
        <div class="info-section">
            <h2 class="panel-title">賽車儀表板</h2>
            
            <div class="stats">
                <div class="stat-box">
                    <div class="stat-label">當前速度</div>
                    <div id="speedValue" class="stat-value">0 km/h</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">當前圈數</div>
                    <div id="lapValue" class="stat-value">0/3</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">最快圈速</div>
                    <div id="bestLapValue" class="stat-value">--:--.---</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">當前圈速</div>
                    <div id="currentLapValue" class="stat-value">--:--.---</div>
                </div>
            </div>
            
            <div class="ranking">
                <h3 class="panel-title">即時排名</h3>
                <div id="rankingList">
                    <!-- 排名將由JavaScript動態生成 -->
                </div>
            </div>
            
            <div class="lap-times">
                <h3 class="panel-title">圈速記錄</h3>
                <table>
                    <thead>
                        <tr>
                            <th>圈數</th>
                            <th>時間</th>
                            <th>差異</th>
                        </tr>
                    </thead>
                    <tbody id="lapTimesBody">
                        <!-- 圈速記錄將由JavaScript動態生成 -->
                    </tbody>
                </table>
            </div>
            
            <div class="instructions">
                <h3>操作說明</h3>
                <ul>
                    <li><strong>方向鍵上</strong>：加速</li>
                    <li><strong>方向鍵下</strong>：減速/倒車</li>
                    <li><strong>方向鍵左右</strong>：轉向</li>
                    <li><strong>空格鍵</strong>：手剎車</li>
                    <li><strong>R鍵</strong>：重置車輛位置</li>
                </ul>
            </div>
        </div>
    </div>
    
    <footer>
        <p>極速賽車 HTML5遊戲 &copy; 2023 | 駕駛賽車在各種賽道上飛馳，超越對手，創造最快圈速！</p>
    </footer>

    <script>
        // 遊戲變量
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let gameRunning = false;
        let gamePaused = false;
        let lastTime = 0;
        
        // 賽車參數 - 進一步降低速度，控制在35km/h以內
        const car = {
            x: 400,
            y: 500,
            width: 25,
            height: 40,
            speed: 0,
            maxSpeed: 3.5, // 降低到約35km/h (3.5 * 10 = 35)
            acceleration: 0.08, // 進一步降低加速度
            deceleration: 0.15, // 增加自然減速
            brakeDeceleration: 0.5, // 增加剎車減速
            reverseSpeed: 1.5, // 降低倒車速度
            angle: 0,
            steerAngle: 0.05, // 調整轉向角度
            friction: 0.97, // 增加摩擦力
            color: '#FF8C00',
            currentCheckpoint: 0,
            lap: 0,
            lapTimes: [],
            bestLapTime: null,
            currentLapStartTime: 0
        };
        
        // 賽道數據
        const tracks = {
            1: { // 城市賽道 - 方形賽道
                name: "城市賽道",
                bgColor: "#333344",
                trackColor: "#555577",
                borderColor: "#FFFFFF",
                innerTrackColor: "#666688",
                startLine: {x1: 150, y1: 550, x2: 250, y2: 550},
                checkpoints: [
                    {x: 200, y: 550, radius: 40},
                    {x: 200, y: 200, radius: 40},
                    {x: 600, y: 200, radius: 40},
                    {x: 600, y: 550, radius: 40}
                ],
                obstacles: [
                    {x: 400, y: 300, width: 60, height: 60},
                    {x: 300, y: 400, width: 40, height: 40},
                    {x: 500, y: 400, width: 40, height: 40}
                ],
                decorative: [
                    {type: 'building', x: 50, y: 50, width: 30, height: 100},
                    {type: 'building', x: 50, y: 200, width: 30, height: 150},
                    {type: 'building', x: 750, y: 100, width: 30, height: 120},
                    {type: 'tree', x: 100, y: 80, size: 15},
                    {type: 'tree', x: 700, y: 80, size: 15}
                ]
            },
            2: { // 山區賽道 - 曲折賽道
                name: "山區賽道",
                bgColor: "#224422",
                trackColor: "#336633",
                borderColor: "#8B4513",
                innerTrackColor: "#447744",
                startLine: {x1: 100, y1: 550, x2: 200, y2: 550},
                checkpoints: [
                    {x: 150, y: 550, radius: 40},
                    {x: 300, y: 150, radius: 40},
                    {x: 650, y: 150, radius: 40},
                    {x: 500, y: 500, radius: 40}
                ],
                obstacles: [
                    {x: 400, y: 300, width: 50, height: 30, type: 'rock'},
                    {x: 500, y: 400, width: 50, height: 30, type: 'rock'},
                    {x: 300, y: 400, width: 40, height: 40, type: 'rock'}
                ],
                decorative: [
                    {type: 'mountain', x: 50, y: 50, width: 100, height: 80},
                    {type: 'mountain', x: 700, y: 50, width: 100, height: 60},
                    {type: 'tree', x: 200, y: 200, size: 20},
                    {type: 'tree', x: 600, y: 200, size: 20},
                    {type: 'tree', x: 400, y: 350, size: 18}
                ]
            },
            3: { // 沙漠賽道 - 橢圓形賽道
                name: "沙漠賽道",
                bgColor: "#8B7355",
                trackColor: "#D2691E",
                borderColor: "#8B4513",
                innerTrackColor: "#DEB887",
                startLine: {x1: 200, y1: 550, x2: 300, y2: 550},
                checkpoints: [
                    {x: 250, y: 550, radius: 40},
                    {x: 250, y: 150, radius: 40},
                    {x: 550, y: 150, radius: 40},
                    {x: 550, y: 550, radius: 40}
                ],
                obstacles: [
                    {x: 400, y: 350, width: 70, height: 70, type: 'sand'},
                    {x: 300, y: 250, width: 50, height: 50, type: 'sand'},
                    {x: 500, y: 450, width: 50, height: 50, type: 'sand'},
                    {x: 300, y: 450, width: 50, height: 50, type: 'sand'},
                    {x: 500, y: 250, width: 50, height: 50, type: 'sand'}
                ],
                decorative: [
                    {type: 'cactus', x: 100, y: 100, size: 30},
                    {type: 'cactus', x: 700, y: 100, size: 25},
                    {type: 'cactus', x: 100, y: 500, size: 35},
                    {type: 'cactus', x: 700, y: 500, size: 28},
                    {type: 'rock', x: 200, y: 300, size: 20}
                ]
            }
        };
        
        // 當前賽道
        let currentTrack = 1;
        let trackData = tracks[currentTrack];
        
        // 對手車輛 - 改進AI
        const opponents = [
            {x: 450, y: 500, width: 25, height: 40, speed: 2.5, angle: 0, color: '#0055AA', name: '藍色閃電', 
             ai: {aggression: 0.8, skill: 0.7, consistency: 0.9},
             currentCheckpoint: 0, lap: 0, lapTimes: [], bestLapTime: null, currentLapStartTime: 0},
            {x: 350, y: 500, width: 25, height: 40, speed: 2.3, angle: 0, color: '#FF0000', name: '紅色旋風',
             ai: {aggression: 0.9, skill: 0.8, consistency: 0.7},
             currentCheckpoint: 0, lap: 0, lapTimes: [], bestLapTime: null, currentLapStartTime: 0},
            {x: 400, y: 450, width: 25, height: 40, speed: 2.0, angle: 0, color: '#00AA00', name: '綠色獵鷹',
             ai: {aggression: 0.6, skill: 0.9, consistency: 0.8},
             currentCheckpoint: 0, lap: 0, lapTimes: [], bestLapTime: null, currentLapStartTime: 0}
        ];
        
        // 遊戲狀態
        const gameState = {
            lap: 0,
            maxLaps: 3,
            raceStartTime: 0,
            raceTime: 0,
            keys: {},
            handbrake: false,
            ranking: [],
            raceFinished: false
        };
        
        // 繪製賽道
        function drawTrack() {
            // 繪製賽道背景
            ctx.fillStyle = trackData.bgColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 根據賽道類型繪製不同的賽道形狀
            if (currentTrack === 1) {
                // 城市賽道 - 矩形
                ctx.fillStyle = trackData.trackColor;
                ctx.fillRect(100, 100, 600, 400);
                
                // 賽道邊界
                ctx.strokeStyle = trackData.borderColor;
                ctx.lineWidth = 10;
                ctx.strokeRect(100, 100, 600, 400);
                
                // 內線
                ctx.strokeStyle = trackData.innerTrackColor;
                ctx.lineWidth = 3;
                ctx.setLineDash([20, 15]);
                ctx.strokeRect(150, 150, 500, 300);
                ctx.setLineDash([]);
                
            } else if (currentTrack === 2) {
                // 山區賽道 - 曲折賽道
                ctx.fillStyle = trackData.trackColor;
                ctx.beginPath();
                ctx.moveTo(150, 100);
                ctx.lineTo(300, 150);
                ctx.lineTo(500, 100);
                ctx.lineTo(650, 150);
                ctx.lineTo(700, 300);
                ctx.lineTo(650, 450);
                ctx.lineTo(500, 500);
                ctx.lineTo(300, 450);
                ctx.lineTo(150, 500);
                ctx.closePath();
                ctx.fill();
                
                // 賽道邊界
                ctx.strokeStyle = trackData.borderColor;
                ctx.lineWidth = 10;
                ctx.stroke();
                
                // 內線
                ctx.strokeStyle = trackData.innerTrackColor;
                ctx.lineWidth = 3;
                ctx.setLineDash([20, 15]);
                ctx.stroke();
                ctx.setLineDash([]);
                
            } else if (currentTrack === 3) {
                // 沙漠賽道 - 橢圓形
                const centerX = 400;
                const centerY = 300;
                const radiusX = 250;
                const radiusY = 150;
                
                ctx.fillStyle = trackData.trackColor;
                ctx.beginPath();
                ctx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // 賽道邊界
                ctx.strokeStyle = trackData.borderColor;
                ctx.lineWidth = 10;
                ctx.stroke();
                
                // 內線
                ctx.strokeStyle = trackData.innerTrackColor;
                ctx.lineWidth = 3;
                ctx.setLineDash([20, 15]);
                ctx.beginPath();
                ctx.ellipse(centerX, centerY, radiusX - 40, radiusY - 40, 0, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            // 繪製起點/終點線
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 4;
            ctx.setLineDash([10, 10]);
            ctx.beginPath();
            ctx.moveTo(trackData.startLine.x1, trackData.startLine.y1);
            ctx.lineTo(trackData.startLine.x2, trackData.startLine.y2);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // 繪製檢查點
            trackData.checkpoints.forEach((checkpoint, index) => {
                ctx.beginPath();
                ctx.arc(checkpoint.x, checkpoint.y, checkpoint.radius, 0, Math.PI * 2);
                ctx.fillStyle = index === car.currentCheckpoint ? '#00FF00' : '#FFFF00';
                ctx.globalAlpha = 0.6;
                ctx.fill();
                ctx.globalAlpha = 1.0;
                
                // 檢查點編號
                ctx.fillStyle = '#FFF';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(index + 1, checkpoint.x, checkpoint.y);
            });
            
            // 繪製障礙物
            trackData.obstacles.forEach(obstacle => {
                if (obstacle.type === 'sand') {
                    // 沙丘
                    ctx.fillStyle = '#F4A460';
                    ctx.beginPath();
                    ctx.ellipse(obstacle.x, obstacle.y, obstacle.width/2, obstacle.height/2, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#8B4513';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                } else {
                    // 一般障礙物
                    ctx.fillStyle = obstacle.type === 'rock' ? '#696969' : '#8B0000';
                    ctx.fillRect(obstacle.x - obstacle.width/2, obstacle.y - obstacle.height/2, obstacle.width, obstacle.height);
                    // 障礙物邊框
                    ctx.strokeStyle = obstacle.type === 'rock' ? '#2F4F4F' : '#660000';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(obstacle.x - obstacle.width/2, obstacle.y - obstacle.height/2, obstacle.width, obstacle.height);
                }
            });
            
            // 繪製裝飾物
            trackData.decorative.forEach(item => {
                if (item.type === 'building') {
                    ctx.fillStyle = '#666699';
                    ctx.fillRect(item.x, item.y, item.width, item.height);
                    // 窗戶
                    ctx.fillStyle = '#87CEEB';
                    for(let i = 0; i < 3; i++) {
                        for(let j = 0; j < 3; j++) {
                            ctx.fillRect(item.x + 5 + j*8, item.y + 5 + i*15, 5, 10);
                        }
                    }
                } else if (item.type === 'tree') {
                    ctx.fillStyle = '#228B22';
                    ctx.beginPath();
                    ctx.arc(item.x, item.y, item.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(item.x - 3, item.y, 6, 15);
                } else if (item.type === 'mountain') {
                    ctx.fillStyle = '#696969';
                    ctx.beginPath();
                    ctx.moveTo(item.x, item.y + item.height);
                    ctx.lineTo(item.x + item.width/2, item.y);
                    ctx.lineTo(item.x + item.width, item.y + item.height);
                    ctx.closePath();
                    ctx.fill();
                } else if (item.type === 'cactus') {
                    ctx.fillStyle = '#32CD32';
                    ctx.fillRect(item.x - 5, item.y, 10, item.size);
                    ctx.fillRect(item.x - 15, item.y + 10, 10, item.size - 20);
                    ctx.fillRect(item.x + 5, item.y + 10, 10, item.size - 20);
                } else if (item.type === 'rock') {
                    ctx.fillStyle = '#A9A9A9';
                    ctx.beginPath();
                    ctx.arc(item.x, item.y, item.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            
            // 繪製賽道名稱
            ctx.fillStyle = '#FFF';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(trackData.name, 60, 90);
        }
        
        // 繪製賽車
        function drawCar(carObj) {
            ctx.save();
            ctx.translate(carObj.x, carObj.y);
            ctx.rotate(carObj.angle);
            
            // 車身
            ctx.fillStyle = carObj.color;
            ctx.fillRect(-carObj.width/2, -carObj.height/2, carObj.width, carObj.height);
            
            // 車窗
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(-carObj.width/4, -carObj.height/3, carObj.width/2, carObj.height/3);
            
            // 車輪
            ctx.fillStyle = '#333';
            ctx.fillRect(-carObj.width/2 - 5, -carObj.height/2, 5, carObj.height);
            ctx.fillRect(carObj.width/2, -carObj.height/2, 5, carObj.height);
            
            // 車頭燈
            ctx.fillStyle = '#FFFF00';
            ctx.fillRect(-carObj.width/4, -carObj.height/2 + 5, carObj.width/4, 5);
            
            // 如果正在剎車，繪製剎車燈
            if (carObj === car && gameState.keys['ArrowDown'] && car.speed > 0) {
                ctx.fillStyle = '#FF0000';
                ctx.fillRect(carObj.width/4, -carObj.height/2 + 5, carObj.width/4, 5);
            }
            
            // 賽車編號
            ctx.fillStyle = '#FFFFFF';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            if (carObj === car) {
                ctx.fillText('01', 0, 0);
            } else {
                const opponentIndex = opponents.indexOf(carObj);
                ctx.fillText(`0${opponentIndex + 2}`, 0, 0);
            }
            
            ctx.restore();
        }
        
        // 初始化排名
        function initRanking() {
            gameState.ranking = [
                {name: "玩家", time: 0, color: car.color, type: "player", lap: 0, finished: false},
                ...opponents.map(opp => ({name: opp.name, time: 0, color: opp.color, type: "opponent", lap: 0, finished: false}))
            ];
            updateRankingDisplay();
        }
        
        // 更新排名顯示
        function updateRankingDisplay() {
            const rankingList = document.getElementById('rankingList');
            rankingList.innerHTML = '';
            
            // 按圈數和時間排序
            const sortedRanking = [...gameState.ranking].sort((a, b) => {
                if (b.finished !== a.finished) return b.finished ? 1 : -1;
                if (b.lap !== a.lap) return b.lap - a.lap;
                return a.time - b.time;
            });
            
            sortedRanking.forEach((racer, index) => {
                const div = document.createElement('div');
                div.className = `ranking-item ${racer.type}`;
                
                const timeStr = racer.time === 0 ? "--:--" : formatTime(racer.time);
                const lapText = racer.finished ? "完成" : `${racer.lap}/${gameState.maxLaps}`;
                
                div.innerHTML = `
                    <div class="ranking-position">#${index + 1}</div>
                    <div class="ranking-name">${racer.name}</div>
                    <div class="ranking-lap">${lapText}</div>
                    <div class="ranking-time">${timeStr}</div>
                `;
                
                rankingList.appendChild(div);
            });
        }
        
        // 改進的AI對手邏輯
        function updateOpponentAI(opponent, deltaTime, currentTime) {
            if (opponent.finished) return;
            
            // 目標檢查點
            const targetCheckpoint = trackData.checkpoints[opponent.currentCheckpoint];
            const dx = targetCheckpoint.x - opponent.x;
            const dy = targetCheckpoint.y - opponent.y;
            const distanceToTarget = Math.sqrt(dx * dx + dy * dy);
            
            // 計算目標角度
            let targetAngle = Math.atan2(dx, -dy);
            
            // 根據AI技能調整轉向
            const skillFactor = opponent.ai.skill;
            const aggression = opponent.ai.aggression;
            
            // 平滑轉向
            let angleDiff = targetAngle - opponent.angle;
            if (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
            if (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
            
            // AI轉向邏輯
            const turnSpeed = 0.025 * skillFactor * deltaTime;
            opponent.angle += Math.sign(angleDiff) * Math.min(Math.abs(angleDiff), turnSpeed);
            
            // AI速度控制 - 根據距離調整速度
            const maxSpeed = 2.5 + aggression * 1.0;
            const minSpeed = 1.0;
            
            if (distanceToTarget > 80) {
                opponent.speed += 0.05 * aggression * deltaTime;
            } else if (distanceToTarget < 30) {
                opponent.speed -= 0.1 * deltaTime;
            }
            
            // 限制速度
            if (opponent.speed > maxSpeed) opponent.speed = maxSpeed;
            if (opponent.speed < minSpeed) opponent.speed = minSpeed;
            
            // 摩擦力
            opponent.speed *= 0.98;
            
            // 更新位置
            opponent.x += Math.sin(opponent.angle) * opponent.speed * deltaTime * 30;
            opponent.y -= Math.cos(opponent.angle) * opponent.speed * deltaTime * 30;
            
            // 邊界檢查
            const trackMargin = 80;
            if (opponent.x < trackMargin) {
                opponent.x = trackMargin;
                opponent.angle += 0.1;
            }
            if (opponent.x > canvas.width - trackMargin) {
                opponent.x = canvas.width - trackMargin;
                opponent.angle -= 0.1;
            }
            if (opponent.y < trackMargin) {
                opponent.y = trackMargin;
                opponent.angle += 0.1;
            }
            if (opponent.y > canvas.height - trackMargin) {
                opponent.y = canvas.height - trackMargin;
                opponent.angle -= 0.1;
            }
            
            // AI檢查點檢測
            const checkpoint = trackData.checkpoints[opponent.currentCheckpoint];
            const cdx = opponent.x - checkpoint.x;
            const cdy = opponent.y - checkpoint.y;
            const checkpointDistance = Math.sqrt(cdx * cdx + cdy * cdy);
            
            if (checkpointDistance < checkpoint.radius) {
                opponent.currentCheckpoint++;
                
                // AI完成一圈
                if (opponent.currentCheckpoint >= trackData.checkpoints.length) {
                    opponent.currentCheckpoint = 0;
                    opponent.lap++;
                    
                    // 記錄圈速
                    const currentTimeSec = currentTime / 1000;
                    const lapTime = currentTimeSec - opponent.currentLapStartTime;
                    opponent.lapTimes.push(lapTime);
                    
                    // 更新最快圈速
                    if (!opponent.bestLapTime || lapTime < opponent.bestLapTime) {
                        opponent.bestLapTime = lapTime;
                    }
                    
                    // 重置當前圈計時
                    opponent.currentLapStartTime = currentTimeSec;
                    
                    // 檢查AI是否完成比賽
                    if (opponent.lap >= gameState.maxLaps) {
                        opponent.finished = true;
                        // 更新排名中的完成狀態
                        const opponentIndex = opponents.indexOf(opponent);
                        if (gameState.ranking[opponentIndex + 1]) {
                            gameState.ranking[opponentIndex + 1].finished = true;
                            gameState.ranking[opponentIndex + 1].time = gameState.raceTime;
                        }
                    }
                }
            }
            
            // 更新排名中的圈數
            const opponentIndex = opponents.indexOf(opponent);
            if (gameState.ranking[opponentIndex + 1]) {
                gameState.ranking[opponentIndex + 1].lap = opponent.lap;
                if (!opponent.finished) {
                    gameState.ranking[opponentIndex + 1].time = gameState.raceTime;
                }
            }
        }
        
        // 改進的賽車物理
        function updateCarPhysics(deltaTime, currentTime) {
            // 處理加速
            if (gameState.keys['ArrowUp']) {
                car.speed += car.acceleration * deltaTime;
                if (car.speed > car.maxSpeed) car.speed = car.maxSpeed;
            }
            // 處理減速/倒車
            else if (gameState.keys['ArrowDown']) {
                if (car.speed > 0) {
                    // 剎車
                    car.speed -= car.brakeDeceleration * deltaTime;
                    if (car.speed < 0) car.speed = 0;
                } else {
                    // 倒車
                    car.speed -= car.acceleration * 0.3 * deltaTime;
                    if (car.speed < -car.reverseSpeed) car.speed = -car.reverseSpeed;
                }
            }
            // 自然減速
            else {
                if (car.speed > 0) {
                    car.speed -= car.deceleration * deltaTime;
                    if (car.speed < 0) car.speed = 0;
                } else if (car.speed < 0) {
                    car.speed += car.deceleration * deltaTime;
                    if (car.speed > 0) car.speed = 0;
                }
            }
            
            // 手剎車效果
            if (gameState.handbrake) {
                car.speed *= 0.92;
            }
            
            // 摩擦力
            car.speed *= car.friction;
            
            // 處理轉向 - 速度越高轉向越困難
            const steeringFactor = 1 - (Math.abs(car.speed) / car.maxSpeed) * 0.6;
            
            if (gameState.keys['ArrowLeft']) {
                car.angle -= car.steerAngle * steeringFactor * deltaTime;
            }
            if (gameState.keys['ArrowRight']) {
                car.angle += car.steerAngle * steeringFactor * deltaTime;
            }
            
            // 更新位置
            car.x += Math.sin(car.angle) * car.speed * deltaTime * 30;
            car.y -= Math.cos(car.angle) * car.speed * deltaTime * 30;
            
            // 邊界檢查 - 確保賽車在賽道內
            const trackMargin = 80;
            if (car.x < trackMargin) {
                car.x = trackMargin;
                car.speed *= 0.7; // 撞牆減速
            }
            if (car.x > canvas.width - trackMargin) {
                car.x = canvas.width - trackMargin;
                car.speed *= 0.7;
            }
            if (car.y < trackMargin) {
                car.y = trackMargin;
                car.speed *= 0.7;
            }
            if (car.y > canvas.height - trackMargin) {
                car.y = canvas.height - trackMargin;
                car.speed *= 0.7;
            }
            
            // 檢查點檢測
            const checkpoint = trackData.checkpoints[car.currentCheckpoint];
            const dx = car.x - checkpoint.x;
            const dy = car.y - checkpoint.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < checkpoint.radius) {
                car.currentCheckpoint++;
                
                // 完成一圈
                if (car.currentCheckpoint >= trackData.checkpoints.length) {
                    car.currentCheckpoint = 0;
                    car.lap++;
                    
                    // 記錄圈速 - 修正：只記錄當前圈的時間
                    const currentTimeSec = currentTime / 1000;
                    const lapTime = currentTimeSec - car.currentLapStartTime;
                    car.lapTimes.push(lapTime);
                    
                    // 更新最快圈速
                    if (!car.bestLapTime || lapTime < car.bestLapTime) {
                        car.bestLapTime = lapTime;
                    }
                    
                    // 重置當前圈計時
                    car.currentLapStartTime = currentTimeSec;
                    
                    // 更新遊戲狀態
                    gameState.lap = car.lap;
                    gameState.ranking[0].lap = car.lap;
                    
                    // 更新顯示
                    updateLapTimesDisplay();
                    
                    // 檢查比賽是否結束
                    if (car.lap >= gameState.maxLaps) {
                        gameState.ranking[0].finished = true;
                        gameState.ranking[0].time = gameState.raceTime;
                        endRace();
                    }
                }
            }
            
            // 障礙物碰撞檢測
            trackData.obstacles.forEach(obstacle => {
                const carLeft = car.x - car.width/2;
                const carRight = car.x + car.width/2;
                const carTop = car.y - car.height/2;
                const carBottom = car.y + car.height/2;
                
                const obstacleLeft = obstacle.x - obstacle.width/2;
                const obstacleRight = obstacle.x + obstacle.width/2;
                const obstacleTop = obstacle.y - obstacle.height/2;
                const obstacleBottom = obstacle.y + obstacle.height/2;
                
                if (carRight > obstacleLeft && 
                    carLeft < obstacleRight && 
                    carBottom > obstacleTop && 
                    carTop < obstacleBottom) {
                    // 碰撞發生，減速並稍微後退
                    car.speed *= -0.4;
                }
            });
            
            // 更新排名中的時間
            gameState.ranking[0].time = gameState.raceTime;
        }
        
        // 防止頁面滾動的函數
        function preventPageScroll(e) {
            if ([32, 37, 38, 39, 40].includes(e.keyCode)) {
                e.preventDefault();
            }
        }
        
        // 格式化時間 - 簡化格式
        function formatTime(time) {
            if (time === 0) return "--:--";
            
            const minutes = Math.floor(time / 60);
            const seconds = Math.floor(time % 60);
            
            return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }
        
        // 格式化圈速時間
        function formatLapTime(time) {
            if (time === 0) return "--:--.---";
            
            const minutes = Math.floor(time / 60);
            const seconds = Math.floor(time % 60);
            const milliseconds = Math.floor((time % 1) * 1000);
            
            return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${milliseconds.toString().padStart(3, '0')}`;
        }
        
        // 更新統計顯示
        function updateStatsDisplay() {
            document.getElementById('speedValue').textContent = Math.abs(Math.round(car.speed * 10)) + " km/h";
            document.getElementById('lapValue').textContent = car.lap + "/" + gameState.maxLaps;
            document.getElementById('bestLapValue').textContent = car.bestLapTime ? formatLapTime(car.bestLapTime) : "--:--.---";
            
            // 計算當前圈速
            if (car.currentLapStartTime > 0 && gameState.raceTime > 0) {
                const currentLapTime = gameState.raceTime - car.currentLapStartTime;
                document.getElementById('currentLapValue').textContent = formatLapTime(currentLapTime);
            } else {
                document.getElementById('currentLapValue').textContent = "--:--.---";
            }
        }
        
        // 更新圈速顯示
        function updateLapTimesDisplay() {
            const lapTimesBody = document.getElementById('lapTimesBody');
            lapTimesBody.innerHTML = '';
            
            car.lapTimes.forEach((lapTime, index) => {
                const row = document.createElement('tr');
                
                // 檢查是否是最快圈
                const isBestLap = car.bestLapTime && Math.abs(lapTime - car.bestLapTime) < 0.001;
                
                const lapCell = document.createElement('td');
                lapCell.textContent = `第${index + 1}圈`;
                
                const timeCell = document.createElement('td');
                timeCell.textContent = formatLapTime(lapTime);
                if (isBestLap) {
                    timeCell.className = 'best-lap';
                }
                
                const diffCell = document.createElement('td');
                if (index === 0) {
                    diffCell.textContent = "-";
                } else {
                    const diff = lapTime - car.lapTimes[index - 1];
                    const diffSign = diff > 0 ? "+" : "-";
                    const absDiff = Math.abs(diff);
                    diffCell.textContent = `${diffSign}${formatLapTime(absDiff)}`;
                    diffCell.style.color = diff > 0 ? "#FF5555" : "#55FF55";
                }
                
                row.appendChild(lapCell);
                row.appendChild(timeCell);
                row.appendChild(diffCell);
                lapTimesBody.appendChild(row);
            });
        }
        
        // 遊戲主循環
        function gameLoop(currentTime = 0) {
            if (!gameRunning || gamePaused) return;
            
            // 計算時間增量
            const deltaTime = Math.min((currentTime - lastTime) / 16.67, 2);
            lastTime = currentTime;
            
            // 清除畫布
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 繪製賽道
            drawTrack();
            
            // 更新遊戲時間
            gameState.raceTime = (currentTime - gameState.raceStartTime) / 1000;
            
            // 更新玩家賽車
            updateCarPhysics(deltaTime, currentTime);
            
            // 更新對手AI
            opponents.forEach(opponent => {
                updateOpponentAI(opponent, deltaTime, currentTime);
            });
            
            // 繪製對手
            opponents.forEach(opponent => {
                drawCar(opponent);
            });
            
            // 繪製玩家賽車
            drawCar(car);
            
            // 繪製遊戲資訊
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(10, 10, 250, 120);
            
            ctx.fillStyle = '#FFF';
            ctx.font = '16px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(`圈數: ${car.lap + 1}/${gameState.maxLaps}`, 20, 35);
            ctx.fillText(`速度: ${Math.abs(Math.round(car.speed * 10))} km/h`, 20, 60);
            
            // 計算當前圈速
            if (car.currentLapStartTime > 0) {
                const currentLapTime = gameState.raceTime - car.currentLapStartTime;
                ctx.fillText(`當前圈速: ${formatLapTime(currentLapTime)}`, 20, 85);
            } else {
                ctx.fillText(`當前圈速: --:--.---`, 20, 85);
            }
            
            ctx.fillText(`最快圈速: ${car.bestLapTime ? formatLapTime(car.bestLapTime) : "--:--.---"}`, 20, 110);
            
            // 更新統計顯示
            updateStatsDisplay();
            updateRankingDisplay();
            
            // 繼續遊戲循環
            requestAnimationFrame(gameLoop);
        }
        
        // 開始比賽
        function startRace() {
            if (gameRunning) return;
            
            gameRunning = true;
            gamePaused = false;
            gameState.raceStartTime = performance.now();
            gameState.raceFinished = false;
            
            // 重置玩家賽車
            car.x = trackData.startLine.x1 + (trackData.startLine.x2 - trackData.startLine.x1) / 2;
            car.y = trackData.startLine.y1;
            car.speed = 0;
            car.angle = 0;
            car.currentCheckpoint = 0;
            car.lap = 0;
            car.lapTimes = [];
            car.bestLapTime = null;
            car.currentLapStartTime = 0;
            
            // 重置對手
            opponents.forEach((opponent, index) => {
                opponent.x = car.x + (index - 1) * 60;
                opponent.y = car.y + 50;
                opponent.angle = 0;
                opponent.speed = 2.0 + index * 0.2;
                opponent.currentCheckpoint = 0;
                opponent.lap = 0;
                opponent.lapTimes = [];
                opponent.bestLapTime = null;
                opponent.currentLapStartTime = 0;
                opponent.finished = false;
            });
            
            // 初始化排名
            initRanking();
            
            // 重置圈速顯示
            updateLapTimesDisplay();
            updateStatsDisplay();
            
            // 設置當前圈開始時間
            car.currentLapStartTime = 0; // 會在第一次通過起點線時設置
            opponents.forEach(opponent => {
                opponent.currentLapStartTime = 0;
            });
            
            // 開始遊戲循環
            lastTime = performance.now();
            requestAnimationFrame(gameLoop);
            
            // 更新按鈕文字
            document.getElementById('startBtn').textContent = "比賽進行中";
            document.getElementById('startBtn').disabled = true;
            
            // 防止頁面滾動
            document.addEventListener('keydown', preventPageScroll);
        }
        
        // 結束比賽
        function endRace() {
            gameRunning = false;
            gameState.raceFinished = true;
            
            // 移除防止滾動的監聽器
            document.removeEventListener('keydown', preventPageScroll);
            
            // 檢查是否所有對手都完成了
            const allFinished = opponents.every(opp => opp.finished);
            
            // 顯示比賽結果
            setTimeout(() => {
                let resultMessage = `比賽結束！\n`;
                resultMessage += `最快圈速：${formatLapTime(car.bestLapTime)}\n`;
                resultMessage += `總時間：${formatTime(gameState.raceTime)}\n\n`;
                resultMessage += `最終排名：\n`;
                
                // 計算最終排名
                const finalRanking = [...gameState.ranking].sort((a, b) => {
                    if (b.finished !== a.finished) return b.finished ? 1 : -1;
                    if (b.lap !== a.lap) return b.lap - a.lap;
                    return a.time - b.time;
                });
                
                finalRanking.forEach((racer, index) => {
                    resultMessage += `${index + 1}. ${racer.name} ${racer.finished ? formatTime(racer.time) : "未完賽"}\n`;
                });
                
                alert(resultMessage);
            }, 500);
            
            // 重置按鈕
            document.getElementById('startBtn').textContent = "開始比賽";
            document.getElementById('startBtn').disabled = false;
        }
        
        // 重新開始比賽
        function restartRace() {
            if (gameRunning) {
                endRace();
            }
            setTimeout(startRace, 100);
        }
        
        // 暫停/繼續遊戲
        function togglePause() {
            if (!gameRunning) return;
            
            gamePaused = !gamePaused;
            document.getElementById('pauseBtn').textContent = gamePaused ? "繼續遊戲" : "暫停遊戲";
            
            if (!gamePaused) {
                lastTime = performance.now();
                gameLoop();
            }
        }
        
        // 切換賽道
        function changeTrack(trackId) {
            currentTrack = trackId;
            trackData = tracks[currentTrack];
            
            // 更新按鈕狀態
            document.querySelectorAll('.track-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.track == trackId) {
                    btn.classList.add('active');
                }
            });
            
            // 如果遊戲正在進行，重置賽車位置
            if (gameRunning) {
                car.x = trackData.startLine.x1 + (trackData.startLine.x2 - trackData.startLine.x1) / 2;
                car.y = trackData.startLine.y1;
                car.speed = 0;
                car.angle = 0;
            }
            
            // 重新繪製賽道
            drawTrack();
            if (gameRunning) {
                opponents.forEach(opponent => drawCar(opponent));
            }
            drawCar(car);
        }
        
        // 事件監聽
        document.addEventListener('keydown', (e) => {
            gameState.keys[e.key] = true;
            
            if (e.key === ' ') {
                gameState.handbrake = true;
            }
            
            if (e.key === 'r' || e.key === 'R') {
                // 重置賽車位置
                car.x = trackData.startLine.x1 + (trackData.startLine.x2 - trackData.startLine.x1) / 2;
                car.y = trackData.startLine.y1;
                car.speed = 0;
                car.angle = 0;
            }
        });
        
        document.addEventListener('keyup', (e) => {
            gameState.keys[e.key] = false;
            
            if (e.key === ' ') {
                gameState.handbrake = false;
            }
        });
        
        // 按鈕事件
        document.getElementById('startBtn').addEventListener('click', startRace);
        document.getElementById('restartBtn').addEventListener('click', restartRace);
        document.getElementById('pauseBtn').addEventListener('click', togglePause);
        
        // 賽道選擇事件
        document.querySelectorAll('.track-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                changeTrack(parseInt(btn.dataset.track));
            });
        });
        
        // 初始化遊戲
        function initGame() {
            // 繪製初始賽道
            drawTrack();
            
            // 繪製初始賽車
            opponents.forEach(opponent => drawCar(opponent));
            drawCar(car);
            
            // 初始化排名
            initRanking();
            
            // 更新統計顯示
            updateStatsDisplay();
            
            // 顯示初始訊息
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(canvas.width/2 - 150, canvas.height/2 - 50, 300, 100);
            
            ctx.fillStyle = '#FFD700';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('極速賽車', canvas.width/2, canvas.height/2 - 20);
            
            ctx.fillStyle = '#FFFFFF';
            ctx.font = '18px Arial';
            ctx.fillText('點擊"開始比賽"按鈕開始遊戲', canvas.width/2, canvas.height/2 + 20);
        }
        
        // 開始初始化遊戲
        window.onload = initGame;
    </script>
</body>
</html>