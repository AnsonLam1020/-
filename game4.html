<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ¥µé€Ÿè³½è»Š - é¸é—œå¡</title>
    <style>
        /* æ¨£å¼ä¿æŒä¸è®Šï¼Œèˆ‡åŸä»£ç¢¼ç›¸åŒ */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Microsoft JhengHei', sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
            color: #fff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            overflow-x: hidden;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            width: 100%;
            max-width: 900px;
        }
        
        h1 {
            font-size: 3.5rem;
            color: #FFD700;
            text-shadow: 0 0 10px #FF4500, 0 0 20px #FF8C00;
            margin-bottom: 10px;
            letter-spacing: 3px;
        }
        
        .subtitle {
            font-size: 1.5rem;
            color: #00FFFF;
            margin-bottom: 30px;
            text-shadow: 0 0 5px #00BFFF;
        }
        
        .container {
            width: 100%;
            max-width: 1200px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        #levelSelection {
            width: 100%;
            max-width: 1000px;
        }
        
        #gameScreen {
            width: 100%;
            max-width: 1000px;
            display: none;
        }
        
        .panel-title {
            color: #FFD700;
            font-size: 2rem;
            margin-bottom: 25px;
            text-align: center;
            border-bottom: 3px solid #FF8C00;
            padding-bottom: 10px;
        }
        
        .tracks-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-bottom: 40px;
        }
        
        .track-card {
            background: rgba(0, 30, 60, 0.7);
            border-radius: 15px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 3px solid #0055AA;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            height: 250px;
            justify-content: space-between;
        }
        
        .track-card:hover {
            transform: translateY(-10px);
            box-shadow: 0 15px 30px rgba(0, 100, 255, 0.3);
            border-color: #FF8C00;
            background: rgba(0, 40, 80, 0.8);
        }
        
        .track-card.locked {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        .track-card.locked:hover {
            transform: none;
            box-shadow: none;
            border-color: #0055AA;
            background: rgba(0, 30, 60, 0.7);
        }
        
        .track-number {
            font-size: 2.5rem;
            color: #FFD700;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .track-name {
            font-size: 1.5rem;
            color: #FFFFFF;
            margin-bottom: 10px;
            font-weight: bold;
        }
        
        .difficulty-stars {
            display: flex;
            justify-content: center;
            margin: 10px 0;
        }
        
        .star {
            color: #FFD700;
            font-size: 1.8rem;
            margin: 0 3px;
        }
        
        .star.empty {
            color: #444;
        }
        
        .track-description {
            font-size: 0.9rem;
            color: #87CEEB;
            margin-bottom: 15px;
            line-height: 1.4;
            height: 40px;
            overflow: hidden;
        }
        
        .track-stats {
            display: flex;
            justify-content: space-between;
            width: 100%;
            font-size: 0.85rem;
            color: #87CEEB;
            margin-top: 10px;
        }
        
        .track-stat {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .stat-value {
            font-size: 1.1rem;
            color: #FFFFFF;
            font-weight: bold;
        }
        
        .stat-label {
            font-size: 0.75rem;
            margin-top: 3px;
        }
        
        .lock-icon {
            font-size: 3rem;
            color: #888;
            margin-bottom: 10px;
        }
        
        .lock-text {
            color: #888;
            font-size: 1.2rem;
        }
        
        .back-button {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 10px 20px;
            background: linear-gradient(to bottom, #0055AA, #003366);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 1.1rem;
            transition: all 0.2s;
            z-index: 1000;
        }
        
        .back-button:hover {
            background: linear-gradient(to bottom, #0066CC, #004488);
            transform: translateY(-2px);
        }
        
        .start-button {
            padding: 15px 40px;
            font-size: 1.5rem;
            background: linear-gradient(to bottom, #FF8C00, #FF4500);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            letter-spacing: 2px;
            margin-top: 20px;
        }
        
        .start-button:hover {
            background: linear-gradient(to bottom, #FFA500, #FF6347);
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(255, 69, 0, 0.4);
        }
        
        .start-button:active {
            transform: translateY(2px);
        }
        
        .game-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            width: 100%;
            max-width: 1200px;
            margin-top: 20px;
        }
        
        .game-section {
            flex: 1;
            min-width: 300px;
            max-width: 800px;
        }
        
        .info-section {
            flex: 1;
            min-width: 300px;
            max-width: 350px;
            background: rgba(0, 20, 40, 0.7);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 0 20px rgba(0, 150, 255, 0.3);
            border: 2px solid #0055AA;
        }
        
        #gameCanvas {
            background-color: #111;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(255, 100, 0, 0.5);
            border: 3px solid #FF8C00;
            display: block;
            margin: 0 auto;
        }
        
        .control-panel {
            background: rgba(0, 30, 60, 0.8);
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
            text-align: center;
        }
        
        .stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .stat-box {
            background: rgba(0, 50, 100, 0.7);
            padding: 12px;
            border-radius: 8px;
            border-left: 4px solid #00BFFF;
        }
        
        .stat-label {
            font-size: 0.9rem;
            color: #87CEEB;
        }
        
        .stat-value {
            font-size: 1.5rem;
            color: #FFFFFF;
            font-weight: bold;
            text-shadow: 0 0 5px #00BFFF;
        }
        
        .controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 20px;
        }
        
        .button {
            padding: 12px 20px;
            font-size: 1.1rem;
            background: linear-gradient(to bottom, #FF8C00, #FF4500);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: bold;
            letter-spacing: 1px;
        }
        
        .button:hover {
            background: linear-gradient(to bottom, #FFA500, #FF6347);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 69, 0, 0.4);
        }
        
        .button.secondary {
            background: linear-gradient(to bottom, #0055AA, #003366);
        }
        
        .button.secondary:hover {
            background: linear-gradient(to bottom, #0066CC, #004488);
        }
        
        .instructions {
            margin-top: 25px;
            padding: 15px;
            background: rgba(0, 40, 80, 0.6);
            border-radius: 10px;
            border-left: 4px solid #00FF00;
        }
        
        .instructions h3 {
            color: #00FF00;
            margin-bottom: 10px;
        }
        
        .instructions ul {
            padding-left: 20px;
        }
        
        .instructions li {
            margin-bottom: 8px;
            line-height: 1.4;
        }
        
        .lap-times {
            margin-top: 20px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .lap-times table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .lap-times th {
            background-color: rgba(0, 80, 160, 0.8);
            padding: 8px;
            text-align: left;
        }
        
        .lap-times td {
            padding: 8px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .lap-times tr:nth-child(even) {
            background-color: rgba(0, 40, 80, 0.4);
        }
        
        .lap-times tr:hover {
            background-color: rgba(0, 100, 200, 0.4);
        }
        
        .best-lap {
            color: #FFD700;
            font-weight: bold;
        }
        
        .ranking {
            margin-top: 20px;
        }
        
        .ranking-item {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            background: rgba(0, 50, 100, 0.6);
            margin-bottom: 8px;
            border-radius: 5px;
            border-left: 4px solid;
        }
        
        .player {
            border-left-color: #FF8C00;
        }
        
        .opponent {
            border-left-color: #0055AA;
        }
        
        .ranking-position {
            font-weight: bold;
            color: #FFD700;
            min-width: 30px;
        }
        
        .ranking-name {
            flex-grow: 1;
            margin-left: 10px;
        }
        
        .ranking-lap {
            color: #87CEEB;
            margin-right: 10px;
        }
        
        .ranking-time {
            color: #87CEEB;
            min-width: 80px;
            text-align: right;
        }
        
        .current-track-info {
            background: rgba(0, 40, 80, 0.5);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            border-left: 5px solid #FF8C00;
        }
        
        .current-track-info h3 {
            color: #FFD700;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        footer {
            margin-top: 40px;
            text-align: center;
            color: #87CEEB;
            font-size: 0.9rem;
            padding: 15px;
            border-top: 1px solid rgba(0, 150, 255, 0.3);
            width: 100%;
            max-width: 1200px;
        }
        
        @media (max-width: 768px) {
            .tracks-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .game-container {
                flex-direction: column;
            }
            
            h1 {
                font-size: 2.5rem;
            }
            
            #gameCanvas {
                width: 100%;
                height: auto;
            }
            
            .track-card {
                height: 220px;
            }
        }
        
        @media (max-width: 480px) {
            .tracks-grid {
                grid-template-columns: 1fr;
            }
            
            .track-card {
                height: 200px;
            }
        }
    </style>
</head>
<body>
    <!-- é—œå¡é¸æ“‡é é¢ -->
    <div id="levelSelection">
        <div class="header">
            <h1>æ¥µé€Ÿè³½è»Š</h1>
            <div class="subtitle">é¸æ“‡é—œå¡é–‹å§‹æŒ‘æˆ°ï¼å®Œæˆç°¡å–®é—œå¡å¯è§£é–æ›´å›°é›£çš„è³½é“</div>
        </div>
        
        <div class="container">
            <h2 class="panel-title">é¸æ“‡è³½é“</h2>
            
            <div class="tracks-grid" id="tracksGrid">
                <!-- è³½é“å¡ç‰‡å°‡ç”±JavaScriptå‹•æ…‹ç”Ÿæˆ -->
            </div>
            
            <button id="startGameBtn" class="start-button" style="display:none;">é–‹å§‹éŠæˆ²</button>
        </div>
    </div>
    
    <!-- éŠæˆ²é é¢ -->
    <div id="gameScreen">
        <button id="backToLevels" class="back-button">è¿”å›é¸é—œ</button>
        
        <div class="header">
            <h1>æ¥µé€Ÿè³½è»Š</h1>
            <div class="subtitle" id="gameSubtitle">é§•é§›è³½è»Šåœ¨è³½é“ä¸Šé£›é¦³ï¼Œè¶…è¶Šå°æ‰‹ï¼Œå‰µé€ æœ€å¿«åœˆé€Ÿï¼</div>
        </div>
        
        <div class="current-track-info">
            <h3>
                <span id="currentTrackName">åŸå¸‚è³½é“</span>
                <span id="currentTrackDifficulty">â˜…â˜…â˜†â˜†â˜†</span>
            </h3>
            <div id="currentTrackDescription">ç°¡å–®çš„çŸ©å½¢è³½é“ï¼Œé©åˆæ–°æ‰‹ç·´ç¿’ã€‚</div>
        </div>
        
        <div class="game-container">
            <div class="game-section">
                <canvas id="gameCanvas" width="800" height="600"></canvas>
                
                <div class="control-panel">
                    <div class="controls">
                        <button id="startBtn" class="button">é–‹å§‹æ¯”è³½</button>
                        <button id="restartBtn" class="button secondary">é‡æ–°é–‹å§‹</button>
                        <button id="pauseBtn" class="button secondary">æš«åœ/ç¹¼çºŒ</button>
                    </div>
                </div>
            </div>
            
            <div class="info-section">
                <h2 class="panel-title">è³½è»Šå„€è¡¨æ¿</h2>
                
                <div class="stats">
                    <div class="stat-box">
                        <div class="stat-label">ç•¶å‰é€Ÿåº¦</div>
                        <div id="speedValue" class="stat-value">0 km/h</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">ç•¶å‰åœˆæ•¸</div>
                        <div id="lapValue" class="stat-value">0/3</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">æœ€å¿«åœˆé€Ÿ</div>
                        <div id="bestLapValue" class="stat-value">--:--.---</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">ç•¶å‰åœˆé€Ÿ</div>
                        <div id="currentLapValue" class="stat-value">--:--.---</div>
                    </div>
                </div>
                
                <div class="ranking">
                    <h3 class="panel-title">å³æ™‚æ’å</h3>
                    <div id="rankingList">
                        <!-- æ’åå°‡ç”±JavaScriptå‹•æ…‹ç”Ÿæˆ -->
                    </div>
                </div>
                
                <div class="lap-times">
                    <h3 class="panel-title">åœˆé€Ÿè¨˜éŒ„</h3>
                    <table>
                        <thead>
                            <tr>
                                <th>åœˆæ•¸</th>
                                <th>æ™‚é–“</th>
                                <th>å·®ç•°</th>
                            </tr>
                        </thead>
                        <tbody id="lapTimesBody">
                            <!-- åœˆé€Ÿè¨˜éŒ„å°‡ç”±JavaScriptå‹•æ…‹ç”Ÿæˆ -->
                        </tbody>
                    </table>
                </div>
                
                <div class="instructions">
                    <h3>æ“ä½œèªªæ˜</h3>
                    <ul>
                        <li><strong>æ–¹å‘éµä¸Š</strong>ï¼šåŠ é€Ÿ</li>
                        <li><strong>æ–¹å‘éµä¸‹</strong>ï¼šæ¸›é€Ÿ/å€’è»Š</li>
                        <li><strong>æ–¹å‘éµå·¦å³</strong>ï¼šè½‰å‘</li>
                        <li><strong>ç©ºæ ¼éµ</strong>ï¼šæ‰‹å‰è»Š</li>
                        <li><strong>Réµ</strong>ï¼šé‡ç½®è»Šè¼›ä½ç½®</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
    
    <footer>
        <p>æ¥µé€Ÿè³½è»Š HTML5éŠæˆ² &copy; 2023 | é§•é§›è³½è»Šåœ¨å„ç¨®è³½é“ä¸Šé£›é¦³ï¼Œè¶…è¶Šå°æ‰‹ï¼Œå‰µé€ æœ€å¿«åœˆé€Ÿï¼</p>
    </footer>

    <script>
        // éŠæˆ²æ•¸æ“š
        const gameData = {
            unlockedLevels: [1], // åˆå§‹è§£é–ç¬¬ä¸€é—œ
            selectedLevel: 1,
            bestTimes: {} // å„²å­˜æ¯å€‹é—œå¡çš„æœ€ä½³æ™‚é–“
        };
        
        // å„²å­˜éŠæˆ²æ•¸æ“šåˆ°localStorage
        function saveGameData() {
            localStorage.setItem('racingGameData', JSON.stringify(gameData));
        }
        
        // è¼‰å…¥éŠæˆ²æ•¸æ“š
        function loadGameData() {
            const savedData = localStorage.getItem('racingGameData');
            if (savedData) {
                Object.assign(gameData, JSON.parse(savedData));
            }
        }
        
        // è§£é–æ–°é—œå¡
        function unlockLevel(level) {
            if (!gameData.unlockedLevels.includes(level)) {
                gameData.unlockedLevels.push(level);
                gameData.unlockedLevels.sort((a, b) => a - b);
                saveGameData();
                return true;
            }
            return false;
        }
        
        // æ›´æ–°æœ€ä½³æ™‚é–“
        function updateBestTime(level, time) {
            if (!gameData.bestTimes[level] || time < gameData.bestTimes[level]) {
                gameData.bestTimes[level] = time;
                saveGameData();
                return true;
            }
            return false;
        }
        
        // è³½é“æ•¸æ“š - å·²ä¿®æ”¹ï¼šå¢å¯¬è³½é“ã€æ­£ç¢ºæ”¾ç½®æª¢æŸ¥é»ã€ç§»é™¤éšœç¤™ç‰©
        const tracks = {
            1: {
                name: "æ–°æ‰‹è¨“ç·´å ´",
                difficulty: 1,
                description: "ç°¡å–®çš„çŸ©å½¢è³½é“ï¼Œé©åˆæ–°æ‰‹ç·´ç¿’åŸºæœ¬é§•é§›æŠ€å·§ã€‚",
                requirements: "ç„¡",
                laps: 2,
                obstacles: 0, // ç§»é™¤éšœç¤™ç‰©
                bgColor: "#333344",
                trackColor: "#555577",
                borderColor: "#FFFFFF",
                innerTrackColor: "#666688",
                trackWidth: 650, // å¢åŠ è³½é“å¯¬åº¦
                trackHeight: 450,
                trackX: 75, // è³½é“èµ·å§‹Xä½ç½®
                trackY: 75, // è³½é“èµ·å§‹Yä½ç½®
                startLine: {x1: 125, y1: 525, x2: 225, y2: 525},
                checkpoints: [
                    {x: 175, y: 525, radius: 40}, // èµ·é»ç·š
                    {x: 175, y: 150, radius: 40}, // å·¦ä¸Šè§’
                    {x: 625, y: 150, radius: 40}, // å³ä¸Šè§’
                    {x: 625, y: 525, radius: 40}  // å³ä¸‹è§’
                ],
                obstacles: [], // ç©ºé™£åˆ—ï¼Œç„¡éšœç¤™ç‰©
                decorative: [
                    {type: 'building', x: 50, y: 50, width: 30, height: 100},
                    {type: 'building', x: 50, y: 200, width: 30, height: 150},
                    {type: 'building', x: 750, y: 100, width: 30, height: 120},
                    {type: 'tree', x: 100, y: 80, size: 15},
                    {type: 'tree', x: 700, y: 80, size: 15},
                    {type: 'tree', x: 100, y: 520, size: 15},
                    {type: 'tree', x: 700, y: 520, size: 15}
                ],
                trackFriction: 0.97
            },
            2: {
                name: "åŸå¸‚è¡—é“è³½",
                difficulty: 2,
                description: "åŸå¸‚è¡—é“è³½é“ï¼Œæœ‰æ›´å¤šå½é“ã€‚",
                requirements: "å®Œæˆé—œå¡1",
                laps: 2,
                obstacles: 0, // ç§»é™¤éšœç¤™ç‰©
                bgColor: "#444455",
                trackColor: "#666677",
                borderColor: "#FFFFFF",
                innerTrackColor: "#777788",
                trackWidth: 700, // å¢åŠ è³½é“å¯¬åº¦
                trackHeight: 500,
                trackX: 50, // è³½é“èµ·å§‹Xä½ç½®
                trackY: 50, // è³½é“èµ·å§‹Yä½ç½®
                startLine: {x1: 100, y1: 550, x2: 200, y2: 550},
                checkpoints: [
                    {x: 150, y: 550, radius: 35}, // èµ·é»ç·š
                    {x: 150, y: 100, radius: 35}, // å·¦ä¸Šè§’
                    {x: 700, y: 100, radius: 35}, // å³ä¸Šè§’
                    {x: 700, y: 400, radius: 35}, // å³ä¸‹è§’ä¸­é–“
                    {x: 400, y: 400, radius: 35}  // å·¦ä¸‹è§’ä¸­é–“
                ],
                obstacles: [], // ç©ºé™£åˆ—ï¼Œç„¡éšœç¤™ç‰©
                decorative: [
                    {type: 'building', x: 50, y: 50, width: 40, height: 120},
                    {type: 'building', x: 50, y: 250, width: 40, height: 150},
                    {type: 'building', x: 750, y: 80, width: 40, height: 140},
                    {type: 'building', x: 750, y: 300, width: 40, height: 100},
                    {type: 'light', x: 200, y: 100, size: 8},
                    {type: 'light', x: 600, y: 100, size: 8},
                    {type: 'light', x: 200, y: 550, size: 8},
                    {type: 'light', x: 600, y: 550, size: 8}
                ],
                trackFriction: 0.96
            },
            3: {
                name: "å±±å€æŒ‘æˆ°è³½",
                difficulty: 3,
                description: "æ›²æŠ˜çš„å±±è·¯è³½é“ï¼Œéœ€è¦è‰¯å¥½çš„è½‰å‘æ§åˆ¶ã€‚",
                requirements: "å®Œæˆé—œå¡2",
                laps: 3,
                obstacles: 0, // ç§»é™¤éšœç¤™ç‰©
                bgColor: "#224422",
                trackColor: "#336633",
                borderColor: "#8B4513",
                innerTrackColor: "#447744",
                trackWidth: 700, // å¢åŠ è³½é“å¯¬åº¦
                trackHeight: 500,
                trackX: 50, // è³½é“èµ·å§‹Xä½ç½®
                trackY: 50, // è³½é“èµ·å§‹Yä½ç½®
                startLine: {x1: 100, y1: 550, x2: 200, y2: 550},
                checkpoints: [
                    {x: 150, y: 550, radius: 35}, // èµ·é»ç·š
                    {x: 300, y: 100, radius: 35}, // ä¸­é–“åå·¦ä¸Šæ–¹
                    {x: 700, y: 150, radius: 35}, // å³ä¸Šè§’
                    {x: 550, y: 500, radius: 35}  // å³ä¸‹è§’
                ],
                obstacles: [], // ç©ºé™£åˆ—ï¼Œç„¡éšœç¤™ç‰©
                decorative: [
                    {type: 'mountain', x: 50, y: 50, width: 100, height: 80},
                    {type: 'mountain', x: 700, y: 50, width: 100, height: 60},
                    {type: 'tree', x: 200, y: 200, size: 20},
                    {type: 'tree', x: 600, y: 200, size: 20},
                    {type: 'tree', x: 400, y: 350, size: 18},
                    {type: 'tree', x: 200, y: 500, size: 15},
                    {type: 'tree', x: 600, y: 500, size: 15}
                ],
                trackFriction: 0.96
            },
            4: {
                name: "æ²™æ¼ æ‹‰åŠ›è³½",
                difficulty: 4,
                description: "æ²™åœ°è³½é“ï¼Œæ‘©æ“¦åŠ›ä½ï¼Œéœ€è¦ç²¾æº–æ§åˆ¶ã€‚",
                requirements: "å®Œæˆé—œå¡3",
                laps: 3,
                obstacles: 0, // ç§»é™¤éšœç¤™ç‰©
                bgColor: "#8B7355",
                trackColor: "#D2691E",
                borderColor: "#8B4513",
                innerTrackColor: "#DEB887",
                trackWidth: 700, // å¢åŠ è³½é“å¯¬åº¦
                trackHeight: 500,
                trackX: 50, // è³½é“èµ·å§‹Xä½ç½®
                trackY: 50, // è³½é“èµ·å§‹Yä½ç½®
                startLine: {x1: 200, y1: 550, x2: 300, y2: 550},
                checkpoints: [
                    {x: 250, y: 550, radius: 30}, // èµ·é»ç·š
                    {x: 250, y: 100, radius: 30}, // å·¦ä¸Šè§’
                    {x: 650, y: 100, radius: 30}, // å³ä¸Šè§’
                    {x: 650, y: 550, radius: 30}  // å³ä¸‹è§’
                ],
                obstacles: [], // ç©ºé™£åˆ—ï¼Œç„¡éšœç¤™ç‰©
                decorative: [
                    {type: 'cactus', x: 100, y: 100, size: 30},
                    {type: 'cactus', x: 700, y: 100, size: 25},
                    {type: 'cactus', x: 100, y: 500, size: 35},
                    {type: 'cactus', x: 700, y: 500, size: 28},
                    {type: 'rock', x: 200, y: 300, size: 20},
                    {type: 'rock', x: 600, y: 300, size: 20},
                    {type: 'rock', x: 400, y: 100, size: 15},
                    {type: 'rock', x: 400, y: 500, size: 15}
                ],
                trackFriction: 0.94
            },
            5: {
                name: "å¤œé–“ç«¶é€Ÿè³½",
                difficulty: 4,
                description: "å¤œé–“è³½é“ï¼Œè¦–é‡å—é™ï¼Œéœ€è¦ä¾é è»Šç‡ˆç…§æ˜ã€‚",
                requirements: "å®Œæˆé—œå¡4",
                laps: 3,
                obstacles: 0, // ç§»é™¤éšœç¤™ç‰©
                bgColor: "#000022",
                trackColor: "#333355",
                borderColor: "#8888AA",
                innerTrackColor: "#444466",
                trackWidth: 700, // å¢åŠ è³½é“å¯¬åº¦
                trackHeight: 500,
                trackX: 50, // è³½é“èµ·å§‹Xä½ç½®
                trackY: 50, // è³½é“èµ·å§‹Yä½ç½®
                startLine: {x1: 200, y1: 550, x2: 300, y2: 550},
                checkpoints: [
                    {x: 250, y: 550, radius: 40}, // èµ·é»ç·š
                    {x: 250, y: 100, radius: 40}, // å·¦ä¸Šè§’
                    {x: 650, y: 100, radius: 40}, // å³ä¸Šè§’
                    {x: 650, y: 400, radius: 40}, // å³ä¸‹è§’ä¸­é–“
                    {x: 400, y: 400, radius: 40}  // å·¦ä¸‹è§’ä¸­é–“
                ],
                obstacles: [], // ç©ºé™£åˆ—ï¼Œç„¡éšœç¤™ç‰©
                decorative: [
                    {type: 'light', x: 100, y: 100, size: 10},
                    {type: 'light', x: 700, y: 100, size: 10},
                    {type: 'light', x: 100, y: 500, size: 10},
                    {type: 'light', x: 700, y: 500, size: 10},
                    {type: 'moon', x: 50, y: 50, size: 30},
                    {type: 'star', x: 100, y: 80, size: 5},
                    {type: 'star', x: 150, y: 60, size: 3},
                    {type: 'star', x: 200, y: 90, size: 4},
                    {type: 'star', x: 600, y: 80, size: 4},
                    {type: 'star', x: 650, y: 60, size: 3},
                    {type: 'star', x: 700, y: 90, size: 5}
                ],
                trackFriction: 0.95
            },
            6: {
                name: "å† è»æ±ºè³½åœˆ",
                difficulty: 5,
                description: "å°ˆæ¥­ç´šè³½é“ï¼Œè¤‡é›œçš„å½é“çµ„åˆï¼ŒæŒ‘æˆ°è³½è»Šæ‰‹çš„æ¥µé™ã€‚",
                requirements: "å®Œæˆæ‰€æœ‰é—œå¡",
                laps: 4,
                obstacles: 0, // ç§»é™¤éšœç¤™ç‰©
                bgColor: "#222244",
                trackColor: "#444466",
                borderColor: "#FFD700",
                innerTrackColor: "#666688",
                trackWidth: 700, // å¢åŠ è³½é“å¯¬åº¦
                trackHeight: 500,
                trackX: 50, // è³½é“èµ·å§‹Xä½ç½®
                trackY: 50, // è³½é“èµ·å§‹Yä½ç½®
                startLine: {x1: 150, y1: 550, x2: 250, y2: 550},
                checkpoints: [
                    {x: 200, y: 550, radius: 25}, // èµ·é»ç·š
                    {x: 200, y: 100, radius: 25}, // å·¦ä¸Šè§’
                    {x: 700, y: 100, radius: 25}, // å³ä¸Šè§’
                    {x: 700, y: 350, radius: 25}, // å³é‚Šä¸­é–“
                    {x: 450, y: 350, radius: 25}, // ä¸­é–“
                    {x: 450, y: 550, radius: 25}  // å³ä¸‹è§’
                ],
                obstacles: [], // ç©ºé™£åˆ—ï¼Œç„¡éšœç¤™ç‰©
                decorative: [
                    {type: 'grandstand', x: 50, y: 50, width: 40, height: 100},
                    {type: 'grandstand', x: 750, y: 50, width: 40, height: 100},
                    {type: 'grandstand', x: 50, y: 450, width: 40, height: 100},
                    {type: 'grandstand', x: 750, y: 450, width: 40, height: 100},
                    {type: 'flag', x: 200, y: 80, size: 20},
                    {type: 'flag', x: 700, y: 80, size: 20},
                    {type: 'flag', x: 200, y: 520, size: 20},
                    {type: 'flag', x: 700, y: 520, size: 20},
                    {type: 'podium', x: 350, y: 550, width: 100, height: 20}
                ],
                trackFriction: 0.96
            }
        };
        
        // ç”Ÿæˆæ˜Ÿæ˜ŸHTML
        function getStarsHTML(difficulty) {
            let starsHTML = '';
            for (let i = 0; i < 5; i++) {
                if (i < difficulty) {
                    starsHTML += '<span class="star">â˜…</span>';
                } else {
                    starsHTML += '<span class="star empty">â˜†</span>';
                }
            }
            return starsHTML;
        }
        
        // æ ¼å¼åŒ–æ™‚é–“
        function formatTime(time) {
            if (!time || time === 0) return "--:--";
            
            const minutes = Math.floor(time / 60);
            const seconds = Math.floor(time % 60);
            
            return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }
        
        // è¼‰å…¥é—œå¡é¸æ“‡é é¢
        function loadLevelSelection() {
            const tracksGrid = document.getElementById('tracksGrid');
            tracksGrid.innerHTML = '';
            
            // ç”Ÿæˆé—œå¡å¡ç‰‡
            for (let i = 1; i <= 6; i++) {
                const track = tracks[i];
                const isUnlocked = gameData.unlockedLevels.includes(i);
                const bestTime = gameData.bestTimes[i];
                
                const trackCard = document.createElement('div');
                trackCard.className = `track-card ${isUnlocked ? '' : 'locked'}`;
                trackCard.dataset.level = i;
                
                if (isUnlocked) {
                    trackCard.innerHTML = `
                        <div class="track-number">${i}</div>
                        <div class="track-name">${track.name}</div>
                        <div class="difficulty-stars">${getStarsHTML(track.difficulty)}</div>
                        <div class="track-description">${track.description}</div>
                        <div class="track-stats">
                            <div class="track-stat">
                                <div class="stat-value">${track.laps}</div>
                                <div class="stat-label">åœˆæ•¸</div>
                            </div>
                            <div class="track-stat">
                                <div class="stat-value">${track.obstacles}</div>
                                <div class="stat-label">éšœç¤™ç‰©</div>
                            </div>
                            <div class="track-stat">
                                <div class="stat-value">${bestTime ? formatTime(bestTime) : '--:--'}</div>
                                <div class="stat-label">æœ€ä½³æ™‚é–“</div>
                            </div>
                        </div>
                    `;
                    
                    trackCard.addEventListener('click', () => {
                        selectLevel(i);
                    });
                } else {
                    trackCard.innerHTML = `
                        <div class="lock-icon">ğŸ”’</div>
                        <div class="track-number">${i}</div>
                        <div class="track-name">${track.name}</div>
                        <div class="difficulty-stars">${getStarsHTML(track.difficulty)}</div>
                        <div class="lock-text">${track.requirements}</div>
                    `;
                }
                
                tracksGrid.appendChild(trackCard);
            }
            
            // é¡¯ç¤ºé—œå¡é¸æ“‡é é¢ï¼Œéš±è—éŠæˆ²é é¢
            document.getElementById('levelSelection').style.display = 'block';
            document.getElementById('gameScreen').style.display = 'none';
            
            // éš±è—é–‹å§‹éŠæˆ²æŒ‰éˆ•
            document.getElementById('startGameBtn').style.display = 'none';
        }
        
        // é¸æ“‡é—œå¡
        function selectLevel(level) {
            gameData.selectedLevel = level;
            document.getElementById('startGameBtn').style.display = 'block';
            
            // é«˜äº®é¸ä¸­çš„é—œå¡
            document.querySelectorAll('.track-card').forEach(card => {
                card.style.borderColor = '#0055AA';
                card.style.boxShadow = 'none';
            });
            
            const selectedCard = document.querySelector(`.track-card[data-level="${level}"]`);
            if (selectedCard) {
                selectedCard.style.borderColor = '#FF8C00';
                selectedCard.style.boxShadow = '0 0 20px rgba(255, 140, 0, 0.5)';
            }
        }
        
        // é–‹å§‹éŠæˆ²
        function startGame() {
            const level = gameData.selectedLevel;
            const track = tracks[level];
            
            // æ›´æ–°éŠæˆ²é é¢çš„è³½é“ä¿¡æ¯
            document.getElementById('currentTrackName').textContent = track.name;
            document.getElementById('currentTrackDifficulty').innerHTML = getStarsHTML(track.difficulty);
            document.getElementById('currentTrackDescription').textContent = track.description;
            document.getElementById('gameSubtitle').textContent = `ç¬¬${level}é—œï¼š${track.name}`;
            
            // é¡¯ç¤ºéŠæˆ²é é¢ï¼Œéš±è—é—œå¡é¸æ“‡é é¢
            document.getElementById('levelSelection').style.display = 'none';
            document.getElementById('gameScreen').style.display = 'block';
            
            // åˆå§‹åŒ–éŠæˆ²
            initGame(level);
        }
        
        // è¿”å›é—œå¡é¸æ“‡
        function backToLevelSelection() {
            // åœæ­¢éŠæˆ²å¾ªç’°
            gameRunning = false;
            
            // ä¿å­˜ç•¶å‰éŠæˆ²æ•¸æ“š
            if (car.lap >= gameState.maxLaps && car.bestLapTime) {
                const newBestTime = updateBestTime(gameData.selectedLevel, car.bestLapTime);
                if (newBestTime) {
                    // è§£é–ä¸‹ä¸€é—œ
                    const nextLevel = gameData.selectedLevel + 1;
                    if (nextLevel <= 6) {
                        const unlocked = unlockLevel(nextLevel);
                        if (unlocked) {
                            setTimeout(() => {
                                alert(`æ­å–œï¼æ‚¨å·²è§£é–ç¬¬${nextLevel}é—œï¼`);
                            }, 100);
                        }
                    }
                }
            }
            
            // è¼‰å…¥é—œå¡é¸æ“‡é é¢
            loadLevelSelection();
        }
        
        // åˆå§‹åŒ–é é¢
        window.onload = function() {
            // è¼‰å…¥éŠæˆ²æ•¸æ“š
            loadGameData();
            
            // è¼‰å…¥é—œå¡é¸æ“‡é é¢
            loadLevelSelection();
            
            // è¨­ç½®æŒ‰éˆ•äº‹ä»¶
            document.getElementById('startGameBtn').addEventListener('click', startGame);
            document.getElementById('backToLevels').addEventListener('click', backToLevelSelection);
        };
    </script>

    <script>
        // éŠæˆ²è®Šé‡
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let gameRunning = false;
        let gamePaused = false;
        let lastTime = 0;
        let currentTrackData = null;
        
        // è³½è»Šåƒæ•¸
        const car = {
            x: 400,
            y: 500,
            width: 25,
            height: 40,
            speed: 0,
            maxSpeed: 0.28,
            acceleration: 0.015,
            deceleration: 0.12,
            brakeDeceleration: 0.4,
            reverseSpeed: 0.05,
            angle: 0,
            steerAngle: 0.045,
            friction: 0.97,
            color: '#FF8C00',
            currentCheckpoint: 0,
            lap: 0,
            lapTimes: [],
            bestLapTime: null,
            currentLapStartTime: 0,
            offTrack: false,
            offTrackSlowdown: 0.8
        };
        
        // å°æ‰‹è»Šè¼› - æ·»åŠ æ›´å¤šæ“¬äººåŒ–å±¬æ€§
        let opponents = [];
        
        // éŠæˆ²ç‹€æ…‹
        const gameState = {
            lap: 0,
            maxLaps: 3,
            raceStartTime: 0,
            raceTime: 0,
            keys: {},
            handbrake: false,
            ranking: [],
            raceFinished: false
        };
        
        // æª¢æŸ¥è³½è»Šæ˜¯å¦åœ¨è³½é“ä¸Š
        function isCarOnTrack(carObj) {
            if (!currentTrackData) return true;
            
            // è³½é“é‚Šç•Œ
            const trackLeft = currentTrackData.trackX;
            const trackRight = currentTrackData.trackX + currentTrackData.trackWidth;
            const trackTop = currentTrackData.trackY;
            const trackBottom = currentTrackData.trackY + currentTrackData.trackHeight;
            
            // è³½è»Šçš„å››å€‹è§’é»
            const cos = Math.cos(carObj.angle);
            const sin = Math.sin(carObj.angle);
            const halfWidth = carObj.width / 2;
            const halfHeight = carObj.height / 2;
            
            // è¨ˆç®—æ—‹è½‰å¾Œçš„è§’é»
            const corners = [
                {x: -halfWidth, y: -halfHeight},
                {x: halfWidth, y: -halfHeight},
                {x: halfWidth, y: halfHeight},
                {x: -halfWidth, y: halfHeight}
            ].map(corner => ({
                x: carObj.x + (corner.x * cos - corner.y * sin),
                y: carObj.y + (corner.x * sin + corner.y * cos)
            }));
            
            // æª¢æŸ¥æ‰€æœ‰è§’é»æ˜¯å¦éƒ½åœ¨è³½é“å…§
            for (const corner of corners) {
                if (corner.x < trackLeft || corner.x > trackRight || 
                    corner.y < trackTop || corner.y > trackBottom) {
                    return false;
                }
            }
            
            return true;
        }
        
        // æ ¹æ“šè³½é“é›£åº¦åˆå§‹åŒ–å°æ‰‹ - æ”¹é€²ç‚ºæ›´åƒçœŸäºº
        function initializeOpponentsForGame(difficulty) {
            opponents = [];
            
            // æ›´æ“¬äººåŒ–çš„å°æ‰‹è¨­å®š
            const opponentNames = ['é–ƒé›»éº¥å…‹', 'æ¥µé€Ÿè‰¾å€«', 'æ—‹é¢¨å‚‘å…‹', 'é£›é¦³è‰è', 'è³½é“ç‹è€…', 'å½é“å°ˆå®¶'];
            const opponentColors = ['#0055AA', '#FF0000', '#00AA00', '#FFD700', '#FF69B4', '#800080'];
            
            // æ›´çœŸå¯¦çš„é§•é§›é¢¨æ ¼
            const drivingStyles = [
                {type: 'aggressive', name: 'æ”»æ“Šå‹', maxSpeedMult: 1.05, skill: 0.9, consistency: 0.8},
                {type: 'defensive', name: 'é˜²å®ˆå‹', maxSpeedMult: 0.95, skill: 0.95, consistency: 0.9},
                {type: 'balanced', name: 'å‡è¡¡å‹', maxSpeedMult: 1.0, skill: 0.85, consistency: 0.85},
                {type: 'risky', name: 'å†’éšªå‹', maxSpeedMult: 1.1, skill: 0.8, consistency: 0.7},
                {type: 'technical', name: 'æŠ€è¡“å‹', maxSpeedMult: 0.98, skill: 1.0, consistency: 0.95},
                {type: 'rookie', name: 'æ–°æ‰‹å‹', maxSpeedMult: 0.9, skill: 0.75, consistency: 0.6}
            ];
            
            // æ ¹æ“šé›£åº¦èª¿æ•´å°æ‰‹æ•¸é‡å’Œèƒ½åŠ›
            let numOpponents;
            switch(difficulty) {
                case 1: numOpponents = 2; break;
                case 2: numOpponents = 3; break;
                case 3: numOpponents = 4; break;
                case 4: numOpponents = 4; break;
                case 5: numOpponents = 5; break;
                default: numOpponents = 3;
            }
            
            for (let i = 0; i < numOpponents; i++) {
                // éš¨æ©Ÿé¸æ“‡é§•é§›é¢¨æ ¼
                const styleIndex = Math.floor(Math.random() * drivingStyles.length);
                const style = drivingStyles[styleIndex];
                
                // æ ¹æ“šé›£åº¦èª¿æ•´åŸºç¤èƒ½åŠ›
                const difficultyFactor = 0.7 + (difficulty * 0.1);
                
                // å€‹æ€§åŒ–AIç‰¹æ€§
                const personality = {
                    aggression: 0.5 + Math.random() * 0.5, // æ”»æ“Šæ€§ 0.5-1.0
                    caution: 0.3 + Math.random() * 0.4,    // è¬¹æ…åº¦ 0.3-0.7
                    impatience: 0.4 + Math.random() * 0.6, // ä¸è€ç…©ç¨‹åº¦ 0.4-1.0
                    adaptability: 0.6 + Math.random() * 0.4, // é©æ‡‰èƒ½åŠ›
                    competitiveness: 0.7 + Math.random() * 0.3, // ç«¶çˆ­æ„è­˜
                    errorProne: 0.1 + Math.random() * 0.3, // å¤±èª¤æ©Ÿç‡
                    recoveryTime: 1000 + Math.random() * 2000 // å¤±èª¤å¾Œæ¢å¾©æ™‚é–“(ms)
                };
                
                // æ“¬äººåŒ–è¡Œç‚ºè¨ˆæ™‚å™¨
                const behaviorTimers = {
                    lastMistake: 0,
                    lastOvertakeAttempt: 0,
                    currentBehavior: 'normal',
                    behaviorChangeTime: 0
                };
                
                // è³½è»Šæ€§èƒ½è®Šç•°
                const carPerformance = {
                    maxSpeed: (0.18 + (difficultyFactor * 0.1)) * style.maxSpeedMult,
                    acceleration: 0.015 + (Math.random() * 0.005),
                    braking: 0.35 + (Math.random() * 0.1),
                    handling: 0.04 + (Math.random() * 0.01)
                };
                
                opponents.push({
                    x: 450 + (i - 1) * 60,
                    y: 500,
                    width: 25,
                    height: 40,
                    speed: carPerformance.maxSpeed * 0.5,
                    angle: 0,
                    color: opponentColors[i],
                    name: opponentNames[i],
                    drivingStyle: style.name,
                    
                    // æ“¬äººåŒ–AIç³»çµ±
                    ai: {
                        personality: personality,
                        skill: style.skill * difficultyFactor,
                        consistency: style.consistency * difficultyFactor,
                        behaviorTimers: behaviorTimers,
                        targetSpeed: carPerformance.maxSpeed,
                        currentTarget: null,
                        overtaking: false,
                        defensive: false,
                        lastPathUpdate: 0,
                        preferredLine: Math.random() > 0.5 ? 'inside' : 'outside',
                        reactionTime: 100 + Math.random() * 200, // åæ‡‰æ™‚é–“(ms)
                        currentFocus: 'racing_line' // ç•¶å‰å°ˆæ³¨é»
                    },
                    
                    carPerformance: carPerformance,
                    
                    currentCheckpoint: 0,
                    lap: 0,
                    lapTimes: [],
                    bestLapTime: null,
                    currentLapStartTime: 0,
                    finished: false,
                    mistakes: 0,
                    lastCheckpointTime: 0,
                    
                    // è³½è»Šè»Œè·¡è¨˜éŒ„
                    racingLine: [],
                    lineIndex: 0
                });
            }
        }
        
        // ç¹ªè£½è³½é“
        function drawTrack() {
            if (!currentTrackData) return;
            
            // ç¹ªè£½è³½é“èƒŒæ™¯
            ctx.fillStyle = currentTrackData.bgColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ç¹ªè£½è³½é“ä¸»é«”
            ctx.fillStyle = currentTrackData.trackColor;
            
            // ä½¿ç”¨æ–°çš„è³½é“åƒæ•¸ç¹ªè£½è³½é“
            ctx.fillRect(
                currentTrackData.trackX, 
                currentTrackData.trackY, 
                currentTrackData.trackWidth, 
                currentTrackData.trackHeight
            );
            
            // è³½é“é‚Šç•Œ
            ctx.strokeStyle = currentTrackData.borderColor;
            ctx.lineWidth = 10;
            ctx.strokeRect(
                currentTrackData.trackX, 
                currentTrackData.trackY, 
                currentTrackData.trackWidth, 
                currentTrackData.trackHeight
            );
            
            // å…§ç·š
            ctx.strokeStyle = currentTrackData.innerTrackColor;
            ctx.lineWidth = 3;
            ctx.setLineDash([20, 15]);
            const innerMargin = 50;
            ctx.strokeRect(
                currentTrackData.trackX + innerMargin, 
                currentTrackData.trackY + innerMargin, 
                currentTrackData.trackWidth - innerMargin * 2, 
                currentTrackData.trackHeight - innerMargin * 2
            );
            ctx.setLineDash([]);
            
            // ç¹ªè£½èµ·é»/çµ‚é»ç·š
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 4;
            ctx.setLineDash([10, 10]);
            ctx.beginPath();
            ctx.moveTo(currentTrackData.startLine.x1, currentTrackData.startLine.y1);
            ctx.lineTo(currentTrackData.startLine.x2, currentTrackData.startLine.y2);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // ç¹ªè£½æª¢æŸ¥é»
            currentTrackData.checkpoints.forEach((checkpoint, index) => {
                ctx.beginPath();
                ctx.arc(checkpoint.x, checkpoint.y, checkpoint.radius, 0, Math.PI * 2);
                ctx.fillStyle = index === car.currentCheckpoint ? '#00FF00' : '#FFFF00';
                ctx.globalAlpha = 0.6;
                ctx.fill();
                ctx.globalAlpha = 1.0;
                
                // æª¢æŸ¥é»ç·¨è™Ÿ
                ctx.fillStyle = '#FFF';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(index + 1, checkpoint.x, checkpoint.y);
            });
            
            // ç¹ªè£½è£é£¾ç‰©
            currentTrackData.decorative.forEach(item => {
                if (item.type === 'building') {
                    ctx.fillStyle = '#666699';
                    ctx.fillRect(item.x, item.y, item.width, item.height);
                    // çª—æˆ¶
                    ctx.fillStyle = '#87CEEB';
                    for(let i = 0; i < 3; i++) {
                        for(let j = 0; j < 3; j++) {
                            ctx.fillRect(item.x + 5 + j*8, item.y + 5 + i*15, 5, 10);
                        }
                    }
                } else if (item.type === 'tree') {
                    ctx.fillStyle = '#228B22';
                    ctx.beginPath();
                    ctx.arc(item.x, item.y, item.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(item.x - 3, item.y, 6, 15);
                } else if (item.type === 'mountain') {
                    ctx.fillStyle = '#696969';
                    ctx.beginPath();
                    ctx.moveTo(item.x, item.y + item.height);
                    ctx.lineTo(item.x + item.width/2, item.y);
                    ctx.lineTo(item.x + item.width, item.y + item.height);
                    ctx.closePath();
                    ctx.fill();
                } else if (item.type === 'cactus') {
                    ctx.fillStyle = '#32CD32';
                    ctx.fillRect(item.x - 5, item.y, 10, item.size);
                    ctx.fillRect(item.x - 15, item.y + 10, 10, item.size - 20);
                    ctx.fillRect(item.x + 5, item.y + 10, 10, item.size - 20);
                } else if (item.type === 'rock') {
                    ctx.fillStyle = '#A9A9A9';
                    ctx.beginPath();
                    ctx.arc(item.x, item.y, item.size, 0, Math.PI * 2);
                    ctx.fill();
                } else if (item.type === 'light') {
                    // è·¯ç‡ˆ
                    ctx.fillStyle = '#FFFF00';
                    ctx.beginPath();
                    ctx.arc(item.x, item.y, item.size, 0, Math.PI * 2);
                    ctx.fill();
                    // å…‰æšˆ
                    ctx.fillStyle = 'rgba(255, 255, 200, 0.3)';
                    ctx.beginPath();
                    ctx.arc(item.x, item.y, item.size * 3, 0, Math.PI * 2);
                    ctx.fill();
                } else if (item.type === 'moon') {
                    // æœˆäº®
                    ctx.fillStyle = '#F0F0F0';
                    ctx.beginPath();
                    ctx.arc(item.x, item.y, item.size, 0, Math.PI * 2);
                    ctx.fill();
                } else if (item.type === 'star') {
                    // æ˜Ÿæ˜Ÿ
                    ctx.fillStyle = '#FFFF00';
                    ctx.beginPath();
                    ctx.arc(item.x, item.y, item.size, 0, Math.PI * 2);
                    ctx.fill();
                } else if (item.type === 'grandstand') {
                    // è§€çœ¾å¸­
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(item.x, item.y, item.width, item.height);
                    // è§€çœ¾
                    ctx.fillStyle = '#FF0000';
                    for(let i = 0; i < 4; i++) {
                        for(let j = 0; j < 3; j++) {
                            ctx.fillRect(item.x + 5 + j*10, item.y + 5 + i*20, 5, 10);
                        }
                    }
                } else if (item.type === 'flag') {
                    // æ——å¹Ÿ
                    ctx.fillStyle = '#FF0000';
                    ctx.fillRect(item.x, item.y, 15, 10);
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillRect(item.x, item.y, 5, 30);
                } else if (item.type === 'podium') {
                    // é ’çå°
                    ctx.fillStyle = '#C0C0C0';
                    ctx.fillRect(item.x, item.y, item.width, item.height);
                    // å°éš
                    ctx.fillRect(item.x - 10, item.y + 5, item.width + 20, 10);
                    ctx.fillRect(item.x - 20, item.y + 15, item.width + 40, 10);
                }
            });
            
            // ç¹ªè£½è³½é“åç¨±
            ctx.fillStyle = '#FFF';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(currentTrackData.name, 60, 90);
            
            // ç¹ªè£½ç•¶å‰é—œå¡
            ctx.fillStyle = '#FFD700';
            ctx.font = 'bold 18px Arial';
            ctx.textAlign = 'right';
            ctx.fillText(`ç¬¬${gameData.selectedLevel}é—œ`, canvas.width - 60, 90);
        }
        
        // ç¹ªè£½è³½è»Š
        function drawCar(carObj) {
            ctx.save();
            ctx.translate(carObj.x, carObj.y);
            ctx.rotate(carObj.angle);
            
            // å¦‚æœä¸åœ¨è³½é“ä¸Šï¼Œæ”¹è®Šè»Šèº«é¡è‰²
            let carColor = carObj.color;
            if (carObj === car && car.offTrack) {
                carColor = '#FF4444'; // ç´…è‰²è¡¨ç¤ºåœ¨è³½é“å¤–
            }
            
            // è»Šèº«
            ctx.fillStyle = carColor;
            ctx.fillRect(-carObj.width/2, -carObj.height/2, carObj.width, carObj.height);
            
            // è»Šçª—
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(-carObj.width/4, -carObj.height/3, carObj.width/2, carObj.height/3);
            
            // è»Šè¼ª
            ctx.fillStyle = '#333';
            ctx.fillRect(-carObj.width/2 - 5, -carObj.height/2, 5, carObj.height);
            ctx.fillRect(carObj.width/2, -carObj.height/2, 5, carObj.height);
            
            // è»Šé ­ç‡ˆ
            ctx.fillStyle = '#FFFF00';
            ctx.fillRect(-carObj.width/4, -carObj.height/2 + 5, carObj.width/4, 5);
            
            // å¦‚æœæ­£åœ¨å‰è»Šï¼Œç¹ªè£½å‰è»Šç‡ˆ
            if (carObj === car && gameState.keys['ArrowDown'] && car.speed > 0) {
                ctx.fillStyle = '#FF0000';
                ctx.fillRect(carObj.width/4, -carObj.height/2 + 5, carObj.width/4, 5);
            }
            
            // è³½è»Šç·¨è™Ÿ
            ctx.fillStyle = '#FFFFFF';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            if (carObj === car) {
                ctx.fillText('01', 0, 0);
            } else {
                const opponentIndex = opponents.indexOf(carObj);
                ctx.fillText(`0${opponentIndex + 2}`, 0, 0);
            }
            
            ctx.restore();
        }
        
        // åˆå§‹åŒ–æ’å
        function initRanking() {
            gameState.ranking = [
                {name: "ç©å®¶", time: 0, color: car.color, type: "player", lap: 0, finished: false},
                ...opponents.map(opp => ({name: opp.name, time: 0, color: opp.color, type: "opponent", lap: 0, finished: false}))
            ];
            updateRankingDisplay();
        }
        
        // æ›´æ–°æ’åé¡¯ç¤º
        function updateRankingDisplay() {
            const rankingList = document.getElementById('rankingList');
            rankingList.innerHTML = '';
            
            // æŒ‰åœˆæ•¸å’Œæ™‚é–“æ’åº
            const sortedRanking = [...gameState.ranking].sort((a, b) => {
                if (b.finished !== a.finished) return b.finished ? 1 : -1;
                if (b.lap !== a.lap) return b.lap - a.lap;
                return a.time - b.time;
            });
            
            sortedRanking.forEach((racer, index) => {
                const div = document.createElement('div');
                div.className = `ranking-item ${racer.type}`;
                
                const timeStr = racer.time === 0 ? "--:--" : formatTime(racer.time);
                const lapText = racer.finished ? "å®Œæˆ" : `${racer.lap}/${gameState.maxLaps}`;
                
                div.innerHTML = `
                    <div class="ranking-position">#${index + 1}</div>
                    <div class="ranking-name">${racer.name}</div>
                    <div class="ranking-lap">${lapText}</div>
                    <div class="ranking-time">${timeStr}</div>
                `;
                
                rankingList.appendChild(div);
            });
        }
        
        // è¨ˆç®—å…©é»ä¹‹é–“çš„è·é›¢
        function distance(x1, y1, x2, y2) {
            return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
        }
        
        // æª¢æŸ¥æ˜¯å¦åœ¨å°æ‰‹å¾Œé¢
        function isBehindOpponent(opponent, target) {
            const dx = target.x - opponent.x;
            const dy = target.y - opponent.y;
            const angleToTarget = Math.atan2(dx, -dy);
            const angleDiff = Math.abs(angleToTarget - opponent.angle);
            return angleDiff < Math.PI / 4; // å¦‚æœåœ¨45åº¦ç¯„åœå…§è¦–ç‚ºåœ¨å¾Œé¢
        }
        
        // é«˜ç´šæ“¬äººåŒ–AIå°æ‰‹é‚è¼¯
        function updateOpponentAI(opponent, deltaTime, currentTime) {
            if (opponent.finished) return;
            
            // æª¢æŸ¥æ˜¯å¦åœ¨è³½é“å¤–
            const isOffTrack = !isCarOnTrack(opponent);
            if (isOffTrack) {
                // å¦‚æœåœ¨è³½é“å¤–ï¼Œæ¸›é€Ÿä¸¦å˜—è©¦è¿”å›è³½é“
                opponent.speed *= 0.85;
                opponent.ai.currentFocus = 'recovery';
                opponent.ai.behaviorTimers.lastMistake = currentTime;
                opponent.mistakes++;
            }
            
            // è™•ç†å¤±èª¤å¾Œæ¢å¾©
            if (currentTime - opponent.ai.behaviorTimers.lastMistake < opponent.ai.personality.recoveryTime) {
                opponent.speed *= 0.95; // å¤±èª¤å¾Œæ›´åŠ è¬¹æ…
            }
            
            // ç›®æ¨™æª¢æŸ¥é»
            const targetCheckpoint = currentTrackData.checkpoints[opponent.currentCheckpoint];
            let targetX = targetCheckpoint.x;
            let targetY = targetCheckpoint.y;
            
            // æ ¹æ“šåå¥½è·¯ç·šèª¿æ•´ç›®æ¨™é»
            if (opponent.ai.preferredLine === 'inside' && opponent.currentCheckpoint > 0) {
                // å…§ç·šè·¯ç·š
                const margin = 60;
                if (targetY < opponent.y) targetY += margin; // ä¸Šå½å…§å´
                if (targetX > opponent.x) targetX -= margin; // å³å½å…§å´
                if (targetX < opponent.x) targetX += margin; // å·¦å½å…§å´
            } else if (opponent.ai.preferredLine === 'outside') {
                // å¤–ç·šè·¯ç·š
                const margin = 60;
                if (targetY < opponent.y) targetY -= margin; // ä¸Šå½å¤–å´
                if (targetX > opponent.x) targetX += margin; // å³å½å¤–å´
                if (targetX < opponent.x) targetX -= margin; // å·¦å½å¤–å´
            }
            
            // æª¢æŸ¥å‰æ–¹æ˜¯å¦æœ‰å…¶ä»–è³½è»Š
            let frontCar = null;
            let minDistance = Infinity;
            
            // æª¢æŸ¥ç©å®¶
            if (opponent.lap === car.lap && distance(opponent.x, opponent.y, car.x, car.y) < 200) {
                const dist = distance(opponent.x, opponent.y, car.x, car.y);
                if (dist < minDistance && isBehindOpponent(opponent, car)) {
                    minDistance = dist;
                    frontCar = {type: 'player', x: car.x, y: car.y, speed: car.speed};
                }
            }
            
            // æª¢æŸ¥å…¶ä»–å°æ‰‹
            opponents.forEach(other => {
                if (other !== opponent && opponent.lap === other.lap) {
                    const dist = distance(opponent.x, opponent.y, other.x, other.y);
                    if (dist < 200 && dist < minDistance && isBehindOpponent(opponent, other)) {
                        minDistance = dist;
                        frontCar = {type: 'opponent', x: other.x, y: other.y, speed: other.speed};
                    }
                }
            });
            
            // å¦‚æœæœ‰å‰è»Šï¼Œèª¿æ•´è¡Œç‚º
            if (frontCar && minDistance < 100) {
                opponent.ai.currentTarget = frontCar;
                opponent.ai.overtaking = true;
                
                // æ ¹æ“šå€‹æ€§æ±ºå®šè¶…è»Šæ™‚æ©Ÿ
                if (minDistance < 50 && opponent.ai.personality.aggression > 0.7) {
                    // æ”»æ“Šæ€§é§•é§›å“¡å˜—è©¦è¶…è»Š
                    opponent.ai.currentFocus = 'overtaking';
                    targetX = frontCar.x + (Math.random() > 0.5 ? 40 : -40);
                    targetY = frontCar.y - 30;
                } else if (minDistance < 30) {
                    // å¤ªè¿‘äº†ï¼Œæ¸›é€Ÿ
                    opponent.ai.targetSpeed = frontCar.speed * 0.9;
                    opponent.ai.currentFocus = 'following';
                } else {
                    // ä¿æŒå®‰å…¨è·é›¢è·Ÿéš¨
                    opponent.ai.targetSpeed = Math.min(frontCar.speed * 1.1, opponent.carPerformance.maxSpeed);
                }
            } else {
                opponent.ai.currentTarget = null;
                opponent.ai.overtaking = false;
                opponent.ai.targetSpeed = opponent.carPerformance.maxSpeed;
                
                // éš¨æ©Ÿè®Šæ›è¡Œç‚ºæ¨¡æ“¬çœŸäºº
                if (Math.random() < 0.01) { // 1%æ©Ÿç‡æ”¹è®Šè¡Œç‚º
                    opponent.ai.currentFocus = Math.random() > 0.5 ? 'aggressive' : 'conservative';
                    opponent.ai.behaviorChangeTime = currentTime + 1000 + Math.random() * 3000;
                }
                
                if (currentTime < opponent.ai.behaviorChangeTime) {
                    if (opponent.ai.currentFocus === 'aggressive') {
                        opponent.ai.targetSpeed = opponent.carPerformance.maxSpeed * 1.05;
                    } else if (opponent.ai.currentFocus === 'conservative') {
                        opponent.ai.targetSpeed = opponent.carPerformance.maxSpeed * 0.9;
                    }
                }
            }
            
            // è¨ˆç®—ç›®æ¨™è§’åº¦
            let targetAngle = Math.atan2(targetX - opponent.x, -(targetY - opponent.y));
            
            // å¹³æ»‘è½‰å‘
            let angleDiff = targetAngle - opponent.angle;
            if (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
            if (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
            
            // æ“¬äººåŒ–è½‰å‘ - æ·»åŠ åæ‡‰æ™‚é–“å’ŒæŠ€èƒ½å½±éŸ¿
            const reactionDelay = opponent.ai.reactionTime / 1000; // è½‰æ›ç‚ºç§’
            const effectiveDeltaTime = deltaTime * (1 - reactionDelay);
            
            // æ ¹æ“šæŠ€èƒ½æ°´å¹³èª¿æ•´è½‰å‘ç²¾åº¦
            const turnPrecision = opponent.ai.skill * 0.8 + 0.2;
            const maxTurnAngle = opponent.carPerformance.handling * turnPrecision * effectiveDeltaTime;
            
            // é€Ÿåº¦è¶Šé«˜è½‰å‘è¶Šå›°é›£
            const speedFactor = 1 - (Math.abs(opponent.speed) / opponent.carPerformance.maxSpeed) * 0.5;
            
            // æ‡‰ç”¨è½‰å‘
            opponent.angle += Math.sign(angleDiff) * Math.min(Math.abs(angleDiff), maxTurnAngle * speedFactor);
            
            // æ“¬äººåŒ–é€Ÿåº¦æ§åˆ¶
            const distanceToTarget = distance(opponent.x, opponent.y, targetX, targetY);
            
            // å½é“é€Ÿåº¦èª¿æ•´
            const isSharpTurn = Math.abs(angleDiff) > Math.PI / 6; // 30åº¦ä»¥ä¸Šè¦–ç‚ºæ€¥å½
            if (isSharpTurn) {
                opponent.ai.targetSpeed *= 0.7; // å½é“æ¸›é€Ÿ
            }
            
            // æ ¹æ“šè·é›¢èª¿æ•´é€Ÿåº¦
            if (distanceToTarget > 100) {
                // è·é›¢é ï¼ŒåŠ é€Ÿ
                opponent.speed += opponent.carPerformance.acceleration * effectiveDeltaTime;
            } else if (distanceToTarget < 40) {
                // è·é›¢è¿‘ï¼Œæº–å‚™æ¸›é€Ÿ
                opponent.speed -= opponent.carPerformance.braking * 0.5 * effectiveDeltaTime;
            } else if (Math.abs(angleDiff) > Math.PI / 12) { // 15åº¦ä»¥ä¸Šå½é“
                // å½é“é©ç•¶æ¸›é€Ÿ
                opponent.speed -= opponent.carPerformance.braking * 0.2 * effectiveDeltaTime;
            }
            
            // æ“¬äººåŒ–éŒ¯èª¤ - æ ¹æ“šå¤±èª¤æ©Ÿç‡éš¨æ©ŸçŠ¯éŒ¯
            if (Math.random() < opponent.ai.personality.errorProne * 0.01) {
                opponent.speed *= 0.8; // çªç„¶æ¸›é€Ÿ
                opponent.ai.behaviorTimers.lastMistake = currentTime;
                opponent.mistakes++;
            }
            
            // é™åˆ¶é€Ÿåº¦
            opponent.speed = Math.max(0.01, Math.min(opponent.speed, opponent.ai.targetSpeed));
            
            // æ“¬äººåŒ–é€Ÿåº¦æ³¢å‹• - æ¨¡æ“¬çœŸäººæ²¹é–€æ§åˆ¶
            const speedVariation = 0.02 * (1 - opponent.ai.consistency);
            opponent.speed *= (1 + (Math.random() * speedVariation - speedVariation/2));
            
            // æ‘©æ“¦åŠ›
            opponent.speed *= currentTrackData.trackFriction || 0.98;
            
            // æ›´æ–°ä½ç½®
            opponent.x += Math.sin(opponent.angle) * opponent.speed * deltaTime * 30;
            opponent.y -= Math.cos(opponent.angle) * opponent.speed * deltaTime * 30;
            
            // æª¢æŸ¥é»æª¢æ¸¬
            const checkpoint = currentTrackData.checkpoints[opponent.currentCheckpoint];
            const checkpointDistance = distance(opponent.x, opponent.y, checkpoint.x, checkpoint.y);
            
            if (checkpointDistance < checkpoint.radius) {
                opponent.currentCheckpoint++;
                opponent.lastCheckpointTime = currentTime;
                
                // å®Œæˆä¸€åœˆ
                if (opponent.currentCheckpoint >= currentTrackData.checkpoints.length) {
                    opponent.currentCheckpoint = 0;
                    opponent.lap++;
                    
                    // è¨˜éŒ„åœˆé€Ÿ
                    const currentTimeSec = currentTime / 1000;
                    const lapTime = currentTimeSec - opponent.currentLapStartTime;
                    opponent.lapTimes.push(lapTime);
                    
                    // æ“¬äººåŒ–åœˆé€Ÿæ³¢å‹•
                    const lapTimeVariation = 0.05 * (1 - opponent.ai.consistency);
                    const adjustedLapTime = lapTime * (1 + (Math.random() * lapTimeVariation - lapTimeVariation/2));
                    
                    // æ›´æ–°æœ€å¿«åœˆé€Ÿ
                    if (!opponent.bestLapTime || adjustedLapTime < opponent.bestLapTime) {
                        opponent.bestLapTime = adjustedLapTime;
                    }
                    
                    // é‡ç½®ç•¶å‰åœˆè¨ˆæ™‚
                    opponent.currentLapStartTime = currentTimeSec;
                    
                    // æª¢æŸ¥AIæ˜¯å¦å®Œæˆæ¯”è³½
                    if (opponent.lap >= gameState.maxLaps) {
                        opponent.finished = true;
                        // æ›´æ–°æ’åä¸­çš„å®Œæˆç‹€æ…‹
                        const opponentIndex = opponents.indexOf(opponent);
                        if (gameState.ranking[opponentIndex + 1]) {
                            gameState.ranking[opponentIndex + 1].finished = true;
                            gameState.ranking[opponentIndex + 1].time = gameState.raceTime;
                        }
                    }
                }
            }
            
            // æ›´æ–°æ’åä¸­çš„åœˆæ•¸
            const opponentIndex = opponents.indexOf(opponent);
            if (gameState.ranking[opponentIndex + 1]) {
                gameState.ranking[opponentIndex + 1].lap = opponent.lap;
                if (!opponent.finished) {
                    gameState.ranking[opponentIndex + 1].time = gameState.raceTime;
                }
            }
        }
        
        // æ ¼å¼åŒ–åœˆé€Ÿæ™‚é–“
        function formatLapTime(time) {
            if (time === 0) return "--:--.---";
            
            const minutes = Math.floor(time / 60);
            const seconds = Math.floor(time % 60);
            const milliseconds = Math.floor((time % 1) * 1000);
            
            return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${milliseconds.toString().padStart(3, '0')}`;
        }
        
        // æ›´æ–°çµ±è¨ˆé¡¯ç¤º
        function updateStatsDisplay() {
            // å°‡é€Ÿåº¦å¾éŠæˆ²å–®ä½è½‰æ›ç‚ºkm/h (ä¹˜ä»¥ç´„36å€)
            const speedInKmh = Math.abs(car.speed * 36);
            document.getElementById('speedValue').textContent = Math.round(speedInKmh) + " km/h";
            document.getElementById('lapValue').textContent = car.lap + "/" + gameState.maxLaps;
            document.getElementById('bestLapValue').textContent = car.bestLapTime ? formatLapTime(car.bestLapTime) : "--:--.---";
            
            // è¨ˆç®—ç•¶å‰åœˆé€Ÿ
            if (car.currentLapStartTime > 0 && gameState.raceTime > 0) {
                const currentLapTime = gameState.raceTime - car.currentLapStartTime;
                document.getElementById('currentLapValue').textContent = formatLapTime(currentLapTime);
            } else {
                document.getElementById('currentLapValue').textContent = "--:--.---";
            }
        }
        
        // æ›´æ–°åœˆé€Ÿé¡¯ç¤º
        function updateLapTimesDisplay() {
            const lapTimesBody = document.getElementById('lapTimesBody');
            lapTimesBody.innerHTML = '';
            
            car.lapTimes.forEach((lapTime, index) => {
                const row = document.createElement('tr');
                
                // æª¢æŸ¥æ˜¯å¦æ˜¯æœ€å¿«åœˆ
                const isBestLap = car.bestLapTime && Math.abs(lapTime - car.bestLapTime) < 0.001;
                
                const lapCell = document.createElement('td');
                lapCell.textContent = `ç¬¬${index + 1}åœˆ`;
                
                const timeCell = document.createElement('td');
                timeCell.textContent = formatLapTime(lapTime);
                if (isBestLap) {
                    timeCell.className = 'best-lap';
                }
                
                const diffCell = document.createElement('td');
                if (index === 0) {
                    diffCell.textContent = "-";
                } else {
                    const diff = lapTime - car.lapTimes[index - 1];
                    const diffSign = diff > 0 ? "+" : "-";
                    const absDiff = Math.abs(diff);
                    diffCell.textContent = `${diffSign}${formatLapTime(absDiff)}`;
                    diffCell.style.color = diff > 0 ? "#FF5555" : "#55FF55";
                }
                
                row.appendChild(lapCell);
                row.appendChild(timeCell);
                row.appendChild(diffCell);
                lapTimesBody.appendChild(row);
            });
        }
        
        // éŠæˆ²ä¸»å¾ªç’°
        function gameLoop(currentTime = 0) {
            if (!gameRunning || gamePaused) return;
            
            // è¨ˆç®—æ™‚é–“å¢é‡
            const deltaTime = Math.min((currentTime - lastTime) / 16.67, 2);
            lastTime = currentTime;
            
            // æ¸…é™¤ç•«å¸ƒ
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // ç¹ªè£½è³½é“
            drawTrack();
            
            // æ›´æ–°éŠæˆ²æ™‚é–“
            gameState.raceTime = (currentTime - gameState.raceStartTime) / 1000;
            
            // æª¢æŸ¥è³½è»Šæ˜¯å¦åœ¨è³½é“ä¸Š
            car.offTrack = !isCarOnTrack(car);
            
            // æ›´æ–°ç©å®¶è³½è»Š
            updateCarPhysics(deltaTime, currentTime);
            
            // æ›´æ–°å°æ‰‹AI
            opponents.forEach(opponent => {
                updateOpponentAI(opponent, deltaTime, currentTime);
            });
            
            // ç¹ªè£½å°æ‰‹
            opponents.forEach(opponent => {
                drawCar(opponent);
            });
            
            // ç¹ªè£½ç©å®¶è³½è»Š
            drawCar(car);
            
            // ç¹ªè£½éŠæˆ²è³‡è¨Š
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(10, 10, 250, 120);
            
            ctx.fillStyle = '#FFF';
            ctx.font = '16px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(`åœˆæ•¸: ${car.lap + 1}/${gameState.maxLaps}`, 20, 35);
            
            // å°‡é€Ÿåº¦å¾éŠæˆ²å–®ä½è½‰æ›ç‚ºkm/h
            const speedInKmh = Math.abs(car.speed * 36);
            ctx.fillText(`é€Ÿåº¦: ${Math.round(speedInKmh)} km/h`, 20, 60);
            
            // å¦‚æœä¸åœ¨è³½é“ä¸Šï¼Œé¡¯ç¤ºè­¦å‘Š
            if (car.offTrack) {
                ctx.fillStyle = '#FF5555';
                ctx.fillText('è­¦å‘Šï¼šé›¢é–‹è³½é“ï¼', 20, 85);
                ctx.fillStyle = '#FFF';
            }
            
            // è¨ˆç®—ç•¶å‰åœˆé€Ÿ
            if (car.currentLapStartTime > 0) {
                const currentLapTime = gameState.raceTime - car.currentLapStartTime;
                ctx.fillText(`ç•¶å‰åœˆé€Ÿ: ${formatLapTime(currentLapTime)}`, 20, car.offTrack ? 110 : 85);
            } else {
                ctx.fillText(`ç•¶å‰åœˆé€Ÿ: --:--.---`, 20, car.offTrack ? 110 : 85);
            }
            
            ctx.fillText(`æœ€å¿«åœˆé€Ÿ: ${car.bestLapTime ? formatLapTime(car.bestLapTime) : "--:--.---"}`, 20, car.offTrack ? 135 : 110);
            
            // æ›´æ–°çµ±è¨ˆé¡¯ç¤º
            updateStatsDisplay();
            updateRankingDisplay();
            
            // ç¹¼çºŒéŠæˆ²å¾ªç’°
            requestAnimationFrame(gameLoop);
        }
        
        // æ”¹é€²çš„è³½è»Šç‰©ç†
        function updateCarPhysics(deltaTime, currentTime) {
            // è™•ç†åŠ é€Ÿ
            if (gameState.keys['ArrowUp']) {
                car.speed += car.acceleration * deltaTime;
                if (car.speed > car.maxSpeed) car.speed = car.maxSpeed;
            }
            // è™•ç†æ¸›é€Ÿ/å€’è»Š
            else if (gameState.keys['ArrowDown']) {
                if (car.speed > 0) {
                    // å‰è»Š
                    car.speed -= car.brakeDeceleration * deltaTime;
                    if (car.speed < 0) car.speed = 0;
                } else {
                    // å€’è»Š
                    car.speed -= car.acceleration * 0.3 * deltaTime;
                    if (car.speed < -car.reverseSpeed) car.speed = -car.reverseSpeed;
                }
            }
            // è‡ªç„¶æ¸›é€Ÿ
            else {
                if (car.speed > 0) {
                    car.speed -= car.deceleration * deltaTime;
                    if (car.speed < 0) car.speed = 0;
                } else if (car.speed < 0) {
                    car.speed += car.deceleration * deltaTime;
                    if (car.speed > 0) car.speed = 0;
                }
            }
            
            // æ‰‹å‰è»Šæ•ˆæœ
            if (gameState.handbrake) {
                car.speed *= 0.92;
            }
            
            // å¦‚æœåœ¨è³½é“å¤–ï¼Œæ¸›é€Ÿæ›´å¤š
            if (car.offTrack) {
                car.speed *= car.offTrackSlowdown;
            }
            
            // æ‘©æ“¦åŠ› - æ ¹æ“šè³½é“é¡å‹èª¿æ•´
            car.speed *= currentTrackData.trackFriction || car.friction;
            
            // è™•ç†è½‰å‘ - é€Ÿåº¦è¶Šé«˜è½‰å‘è¶Šå›°é›£
            const steeringFactor = 1 - (Math.abs(car.speed) / car.maxSpeed) * 0.6;
            
            if (gameState.keys['ArrowLeft']) {
                car.angle -= car.steerAngle * steeringFactor * deltaTime;
            }
            if (gameState.keys['ArrowRight']) {
                car.angle += car.steerAngle * steeringFactor * deltaTime;
            }
            
            // æ›´æ–°ä½ç½®
            const oldX = car.x;
            const oldY = car.y;
            
            car.x += Math.sin(car.angle) * car.speed * deltaTime * 30;
            car.y -= Math.cos(car.angle) * car.speed * deltaTime * 30;
            
            // å¦‚æœç§»å‹•å¾Œä¸åœ¨è³½é“ä¸Šï¼Œå˜—è©¦æ¨å›è³½é“
            if (!isCarOnTrack(car)) {
                // å˜—è©¦å°‡è»Šæ¨å›è³½é“
                const pushBackFactor = 0.5;
                car.x = oldX * (1 - pushBackFactor) + car.x * pushBackFactor;
                car.y = oldY * (1 - pushBackFactor) + car.y * pushBackFactor;
                
                // é€²ä¸€æ­¥æ¸›é€Ÿ
                car.speed *= 0.8;
            }
            
            // æª¢æŸ¥é»æª¢æ¸¬
            const checkpoint = currentTrackData.checkpoints[car.currentCheckpoint];
            const dx = car.x - checkpoint.x;
            const dy = car.y - checkpoint.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < checkpoint.radius) {
                car.currentCheckpoint++;
                
                // å®Œæˆä¸€åœˆ
                if (car.currentCheckpoint >= currentTrackData.checkpoints.length) {
                    car.currentCheckpoint = 0;
                    car.lap++;
                    
                    // è¨˜éŒ„åœˆé€Ÿ - ä¿®æ­£ï¼šåªè¨˜éŒ„ç•¶å‰åœˆçš„æ™‚é–“
                    const currentTimeSec = currentTime / 1000;
                    const lapTime = currentTimeSec - car.currentLapStartTime;
                    car.lapTimes.push(lapTime);
                    
                    // æ›´æ–°æœ€å¿«åœˆé€Ÿ
                    if (!car.bestLapTime || lapTime < car.bestLapTime) {
                        car.bestLapTime = lapTime;
                    }
                    
                    // é‡ç½®ç•¶å‰åœˆè¨ˆæ™‚
                    car.currentLapStartTime = currentTimeSec;
                    
                    // æ›´æ–°éŠæˆ²ç‹€æ…‹
                    gameState.lap = car.lap;
                    gameState.ranking[0].lap = car.lap;
                    
                    // æ›´æ–°é¡¯ç¤º
                    updateLapTimesDisplay();
                    
                    // æª¢æŸ¥æ¯”è³½æ˜¯å¦çµæŸ
                    if (car.lap >= gameState.maxLaps) {
                        gameState.ranking[0].finished = true;
                        gameState.ranking[0].time = gameState.raceTime;
                        endRace();
                    }
                }
            }
        }
        
        // é˜²æ­¢é é¢æ»¾å‹•çš„å‡½æ•¸
        function preventPageScroll(e) {
            if ([32, 37, 38, 39, 40].includes(e.keyCode)) {
                e.preventDefault();
            }
        }
        
        // é–‹å§‹æ¯”è³½
        function startRace() {
            if (gameRunning) return;
            
            gameRunning = true;
            gamePaused = false;
            gameState.raceStartTime = performance.now();
            gameState.raceFinished = false;
            
            // é‡ç½®ç©å®¶è³½è»Š
            car.x = currentTrackData.startLine.x1 + (currentTrackData.startLine.x2 - currentTrackData.startLine.x1) / 2;
            car.y = currentTrackData.startLine.y1;
            car.speed = 0;
            car.angle = 0;
            car.currentCheckpoint = 0;
            car.lap = 0;
            car.lapTimes = [];
            car.bestLapTime = null;
            car.currentLapStartTime = 0;
            car.offTrack = false;
            
            // é‡ç½®å°æ‰‹
            opponents.forEach((opponent, index) => {
                opponent.x = car.x + (index - 1) * 60;
                opponent.y = car.y + 50;
                opponent.angle = 0;
                opponent.speed = 0.1 + index * 0.02;
                opponent.currentCheckpoint = 0;
                opponent.lap = 0;
                opponent.lapTimes = [];
                opponent.bestLapTime = null;
                opponent.currentLapStartTime = 0;
                opponent.finished = false;
                opponent.mistakes = 0;
                opponent.ai.behaviorTimers.lastMistake = 0;
                opponent.ai.behaviorTimers.lastOvertakeAttempt = 0;
                opponent.ai.currentFocus = 'racing_line';
            });
            
            // åˆå§‹åŒ–æ’å
            initRanking();
            
            // é‡ç½®åœˆé€Ÿé¡¯ç¤º
            updateLapTimesDisplay();
            updateStatsDisplay();
            
            // è¨­ç½®ç•¶å‰åœˆé–‹å§‹æ™‚é–“
            car.currentLapStartTime = 0; // æœƒåœ¨ç¬¬ä¸€æ¬¡é€šéèµ·é»ç·šæ™‚è¨­ç½®
            opponents.forEach(opponent => {
                opponent.currentLapStartTime = 0;
            });
            
            // é–‹å§‹éŠæˆ²å¾ªç’°
            lastTime = performance.now();
            requestAnimationFrame(gameLoop);
            
            // æ›´æ–°æŒ‰éˆ•æ–‡å­—
            document.getElementById('startBtn').textContent = "æ¯”è³½é€²è¡Œä¸­";
            document.getElementById('startBtn').disabled = true;
            
            // é˜²æ­¢é é¢æ»¾å‹•
            document.addEventListener('keydown', preventPageScroll);
        }
        
        // çµæŸæ¯”è³½
        function endRace() {
            gameRunning = false;
            gameState.raceFinished = true;
            
            // ç§»é™¤é˜²æ­¢æ»¾å‹•çš„ç›£è½å™¨
            document.removeEventListener('keydown', preventPageScroll);
            
            // æª¢æŸ¥æ˜¯å¦æ‰€æœ‰å°æ‰‹éƒ½å®Œæˆäº†
            const allFinished = opponents.every(opp => opp.finished);
            
            // ä¿å­˜æœ€ä½³æ™‚é–“
            if (car.lap >= gameState.maxLaps && car.bestLapTime) {
                const newBestTime = updateBestTime(gameData.selectedLevel, car.bestLapTime);
                
                // è§£é–ä¸‹ä¸€é—œ
                const nextLevel = gameData.selectedLevel + 1;
                if (nextLevel <= 6 && !gameData.unlockedLevels.includes(nextLevel)) {
                    const unlocked = unlockLevel(nextLevel);
                    if (unlocked) {
                        setTimeout(() => {
                            alert(`æ­å–œï¼æ‚¨å·²è§£é–ç¬¬${nextLevel}é—œï¼`);
                        }, 100);
                    }
                }
            }
            
            // é¡¯ç¤ºæ¯”è³½çµæœ
            setTimeout(() => {
                let resultMessage = `æ¯”è³½çµæŸï¼\n`;
                resultMessage += `è³½é“: ${currentTrackData.name}\n`;
                resultMessage += `æœ€å¿«åœˆé€Ÿï¼š${formatLapTime(car.bestLapTime)}\n`;
                resultMessage += `ç¸½æ™‚é–“ï¼š${formatTime(gameState.raceTime)}\n\n`;
                resultMessage += `æœ€çµ‚æ’åï¼š\n`;
                
                // è¨ˆç®—æœ€çµ‚æ’å
                const finalRanking = [...gameState.ranking].sort((a, b) => {
                    if (b.finished !== a.finished) return b.finished ? 1 : -1;
                    if (b.lap !== a.lap) return b.lap - a.lap;
                    return a.time - b.time;
                });
                
                finalRanking.forEach((racer, index) => {
                    resultMessage += `${index + 1}. ${racer.name} ${racer.finished ? formatTime(racer.time) : "æœªå®Œè³½"}\n`;
                });
                
                // é¡¯ç¤ºå°æ‰‹é§•é§›é¢¨æ ¼
                resultMessage += `\nå°æ‰‹é§•é§›é¢¨æ ¼ï¼š\n`;
                opponents.forEach((opponent, index) => {
                    resultMessage += `${opponent.name}: ${opponent.drivingStyle} (${opponent.mistakes}æ¬¡å¤±èª¤)\n`;
                });
                
                alert(resultMessage);
            }, 500);
            
            // é‡ç½®æŒ‰éˆ•
            document.getElementById('startBtn').textContent = "é–‹å§‹æ¯”è³½";
            document.getElementById('startBtn').disabled = false;
        }
        
        // é‡æ–°é–‹å§‹æ¯”è³½
        function restartRace() {
            if (gameRunning) {
                endRace();
            }
            setTimeout(startRace, 100);
        }
        
        // æš«åœ/ç¹¼çºŒéŠæˆ²
        function togglePause() {
            if (!gameRunning) return;
            
            gamePaused = !gamePaused;
            document.getElementById('pauseBtn').textContent = gamePaused ? "ç¹¼çºŒéŠæˆ²" : "æš«åœéŠæˆ²";
            
            if (!gamePaused) {
                lastTime = performance.now();
                gameLoop();
            }
        }
        
        // åˆå§‹åŒ–éŠæˆ²
        function initGame(level) {
            // è¼‰å…¥è³½é“æ•¸æ“š
            currentTrackData = tracks[level];
            gameState.maxLaps = currentTrackData.laps;
            
            // æ ¹æ“šè³½é“é›£åº¦åˆå§‹åŒ–å°æ‰‹
            initializeOpponentsForGame(currentTrackData.difficulty);
            
            // ç¹ªè£½åˆå§‹è³½é“
            drawTrack();
            
            // ç¹ªè£½åˆå§‹è³½è»Š
            opponents.forEach(opponent => drawCar(opponent));
            drawCar(car);
            
            // åˆå§‹åŒ–æ’å
            initRanking();
            
            // æ›´æ–°çµ±è¨ˆé¡¯ç¤º
            updateStatsDisplay();
            
            // è¨­ç½®éŠæˆ²æŒ‰éˆ•äº‹ä»¶
            document.getElementById('startBtn').addEventListener('click', startRace);
            document.getElementById('restartBtn').addEventListener('click', restartRace);
            document.getElementById('pauseBtn').addEventListener('click', togglePause);
            
            // é¡¯ç¤ºåˆå§‹è¨Šæ¯
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(canvas.width/2 - 150, canvas.height/2 - 50, 300, 100);
            
            ctx.fillStyle = '#FFD700';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(`ç¬¬${level}é—œ`, canvas.width/2, canvas.height/2 - 20);
            
            ctx.fillStyle = '#FFFFFF';
            ctx.font = '18px Arial';
            ctx.fillText('é»æ“Š"é–‹å§‹æ¯”è³½"æŒ‰éˆ•é–‹å§‹éŠæˆ²', canvas.width/2, canvas.height/2 + 20);
        }
        
        // äº‹ä»¶ç›£è½
        document.addEventListener('keydown', (e) => {
            gameState.keys[e.key] = true;
            
            if (e.key === ' ') {
                gameState.handbrake = true;
            }
            
            if (e.key === 'r' || e.key === 'R') {
                // é‡ç½®è³½è»Šä½ç½®
                if (currentTrackData) {
                    car.x = currentTrackData.startLine.x1 + (currentTrackData.startLine.x2 - currentTrackData.startLine.x1) / 2;
                    car.y = currentTrackData.startLine.y1;
                    car.speed = 0;
                    car.angle = 0;
                    car.offTrack = false;
                }
            }
        });
        
        document.addEventListener('keyup', (e) => {
            gameState.keys[e.key] = false;
            
            if (e.key === ' ') {
                gameState.handbrake = false;
            }
        });
    </script>
</body>
</html>